<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>LiuYongQian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="永远相信美好的事情将要发生！">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongQian">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="LiuYongQian">
<meta property="og:description" content="永远相信美好的事情将要发生！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongQian">
<meta name="twitter:description" content="永远相信美好的事情将要发生！">
  
    <link rel="alternate" href="/atom.xml" title="LiuYongQian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongQian</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">永远相信美好的事情将要发生！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-推导" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/推导/" class="article-date">
  <time datetime="2018-02-05T14:52:41.000Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/推导/">推导</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>推导</h5><p></p>
<hr>
<hr>
<h6>三元表达式</h6>

<ul>
<li><p>类似C语言的三元条件表达式condition ? true_part : false_part，虽然Python没有三目运算符(?:)，但也有类似的替代方案，那就是true_part if condition else false_part</p>
<pre><code>m=&apos;Fire&apos; if True else &apos;Water&apos;
print(m)
</code></pre></li>
</ul>
<h6>推导</h6>

<ul>
<li>推导式是Python中很强大的、很受欢迎的特性，具有语言简洁，速度快等优点</li>
<li><p>列表推导式</p>
<pre><code>list1=[]                       #例子1：10之内整除3的数
for i in range(10):
    if i%3==0:
        list1.append(i)
print(list1)                   #result:[0, 3, 6, 9]

n=[i for i in range(10) if i%3==0]   #使用推导
print(n)                             #result:[0, 3, 6, 9]

def squared(x):                #例子2,10之内整除3的数的平方
    return x*x
list2=[]
for i in range(10):
    if i%3==0:
        list2.append(squared(i))
print(list2)                   #result:[0, 9, 36, 81]

n=[squared(i) for i in range(10) if i%3==0]  #使用推导
print(n)                                     #result:[0, 9, 36, 81]

m=(squared(i) for i in range(10) if i%3==0)  #使用()生成generator将俩表推导式的[]改成()即可得到生成器
print(type(m))                 #result:&lt;class &apos;generator&apos;&gt;
print(next(m))                 #result:0
print(next(m))                 #result:9
</code></pre></li>
<li><p>字典推导式<br>字典推导和列表推导的使用方法是类似的，只不过中括号改成大括号</p>
<pre><code>dict1={&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3}
for k,v in dict1.items():
    print(k,v)                 #result:b 2     c 3     a 1

n={(k,v) for k,v in dict1.items()}  #(k,v)可以写成k:v,就是要保证是一个值
print(n)                            #result:{(&apos;c&apos;, 3), (&apos;a&apos;, 1), (&apos;b&apos;, 2)}
</code></pre></li>
<li><p>集合推导式<br>跟列表推导式也是类似的，唯一的区别在于它使用大括号{}</p>
<pre><code>#用集合推导获取字符串长度的集合
set1=[&apos;a&apos;,&apos;is&apos;,&apos;with&apos;,&apos;if&apos;,&apos;file&apos;,&apos;exception&apos;]
m={len(i) for i in set1}
print(m)                        #result:{1, 2, 4, 9}
</code></pre></li>
</ul>
<h6>小练习</h6>

<pre><code>#练习1,0--9的次方
n={i*i for i in range(10)}
print(n)                        #result:{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}

#练习2,将单词长度大于3的转化为大写输出
n={&apos;Liu&apos;,&apos;yong&apos;,&apos;qian&apos;,&apos;is&apos;,&apos;a&apos;,&apos;engineer&apos;}
m=[i.upper() for i in n if len(i)&gt;3]
print(m)                        #result:[&apos;YONG&apos;, &apos;ENGINEER&apos;, &apos;QIAN&apos;]

#练习3,求(x,y)其中x是0-5之间的偶数，y是0-5之间的奇数组成的元祖列表
n=[(x,y) for x in range(0,6,2) for y in range(1,6,2)]
print(n)                        #result:[(0, 1), (0, 3), (0, 5), (2, 1), (2, 3), (2, 5), (4, 1), (4, 3), (4, 5)]

#练习4,求n中3,6,9组成的列表，斜线1,5,9组成的列表
n=[[1,2,3],[4,5,6],[7,8,9]]
m=[i[2] for i in n]
print(m)                        #result:[3, 6, 9]

m=[n[i][i] for i in range(len(n))]
print(m)                        #result:[1, 5, 9]

#练习5,求m,n中矩阵元素的乘积
n=[[1,2,3],[4,5,6],[7,8,9]]
m=[[2,2,2],[3,3,3],[4,4,4]]

a=[n[i][j]*m[i][j] for i in range(len(n)) for j in range(len(n[i]))]
print(a)                        #result:[2, 4, 6, 12, 15, 18, 28, 32, 36]

#练习6,组成不重复数字的3位数组合
a=[1,2,3,4]
b=[1,2,3,4]
c=[1,2,3,4]

m=[i*100+j*10+k for i in a for j in b for k in c if i!=j and i!=k and j!=k]
print(m)

#练习7
n=[[1,2,3,4],[2,4,6,8],[3,5,7,9]]
m=[[n[i][j] for i in range(3)] for j in range(4)]
print(m)                        #result:[[1, 2, 3], [2, 4, 5], [3, 6, 7], [4, 8, 9]]
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/05/推导/" data-id="cjfclw984004ca0wveytcsjy9" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-随机数Random" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/02/随机数Random/" class="article-date">
  <time datetime="2018-02-02T11:11:33.000Z" itemprop="datePublished">2018-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/02/随机数Random/">随机数Random</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>Random随机数</h5><p></p>
<hr>
<hr>
<p></p><h6>常用函数</h6><p></p>
<ul>
<li><p>random() 用于生成一个0到1的随机浮点数</p>
<pre><code>print(random.random())                  #result:0.3319445476632338
</code></pre></li>
<li><p>uniform(x,y) 用于生成指定该范围内的随机浮点数，两个参数其中一个是上限，一个是下限，可以不考虑先后顺序</p>
<pre><code>print(random.uniform(1,9))              #result:6.238616035651107
</code></pre></li>
<li><p>randint(x,y) 用于生成一个指定范围内的整数，两个参数其中x为下限，y为上限</p>
<pre><code>print(random.randint(1,9))              #result:8
</code></pre></li>
<li><p>randrange(start,stop,step) 从指定范围内，按指定基数递增的集合中，获取一个随机数</p>
<pre><code>print(random.randrange(1,9,2))          #相当于从[1,3,5,7]序列中获取一个随机数
</code></pre></li>
<li><p>choice() 从序列中获取一个随机元素</p>
<pre><code>print(random.choice(&apos;LiuYongqian&apos;))     #result:Y
</code></pre></li>
<li><p>shuffle() 用于将一个列表中的元素打乱</p>
<pre><code>m=[&apos;Liu&apos;,&apos;Yong&apos;,&apos;Qian&apos;]
random.shuffle(m)
print(m)                                #result:[&apos;Yong&apos;, &apos;Liu&apos;, &apos;Qian&apos;]
</code></pre></li>
<li><p>sample() 从指定序列中随机获取指定长度的片断，该函数不会修改原有序列</p>
<pre><code>m=[0,1,2,3,4,5,6,7,8,9]
n=random.sample(m,5)
print(n)                                #result:[2, 8, 5, 1, 3]
</code></pre></li>
</ul>
<p></p><h6>双色球</h6><p></p>
<ul>
<li><p>运用sample()函数实现</p>
<pre><code>import random
list1,list2=range(1,34),range(1,17)
blue=random.sample(list1,6)
blue.sort()
red=random.sample(list2,1)

ball=blue+red
print(ball)                             #result:[3, 5, 9, 11, 31, 32, 10]
</code></pre></li>
<li><p>运用递归实现</p>
<pre><code>import random
list1,list2=range(1,34),range(1,17)
ball=[]
def getBlueNum():
    m=random.choice(list1)
    if m not in ball:
        ball.append(m)
    else:
        getBlueNum()

for i in range(6):
    getBlueNum()
rednum=random.sample(list2,1)
ball.append(rednum)
print(ball)                             #result:[8, 18, 30, 31, 20, 11, [16]]
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/02/随机数Random/" data-id="cjfclw99v005aa0wvirf08yiz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-日志Logging" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/02/日志Logging/" class="article-date">
  <time datetime="2018-02-02T11:11:21.000Z" itemprop="datePublished">2018-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/02/日志Logging/">日志Logging</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>日志Logging</h5><p></p>
<hr>
<hr>
<h6>基础知识</h6>

<ul>
<li>Python的logging模块提供了记录程序运行情况的日志功能，logging模块主要可以根据自定义日志信息，在程序运行的时候将日志打印在终端及记录日志到文件中。默认情况下，logging打印日志级别为warning,而debug、info在warning级别之下，故而不打印<br></li>
<li>日志级别，由低到高<ul>
<li>debug() 调试级别，一般用于记录程序运行的详细信息</li>
<li>info()事件级别，一般用于记录程序的运行过程</li>
<li>warnning() 警告级别，，一般用于记录程序出现潜在错误的情形</li>
<li>error() 错误级别，一般用于记录程序出现错误，但不影响整体运行</li>
<li>critical() 严重错误级别 ， 出现该错误已经影响到整体运行</li>
</ul>
</li>
<li>logging模块的四大组件<ul>
<li>Logger：提供日志接口，供应用代码使用。logger最长用的操作有两类：配置和发送日志消息。可以通过logging.getLogger(name)获取logger对象，如果不指定name则返回root对象，多次使用相同的name调用getLogger方法返回同一个logger对象</li>
<li>Handler：将日志记录（log record）发送到合适的目的地（destination），比如文件，socket等。一个logger对象可以通过addHandler方法添加0到多个handler，每个handler又可以定义不同日志级别，以实现日志分级过滤显示</li>
<li>Filter：提供一种优雅的方式决定一个日志记录是否发送到handler</li>
<li>Formatter：指定日志记录输出的具体格式。formatter的构造方法需要两个参数：消息的格式字符串和日期字符串，这两个参数都是可选的</li>
</ul>
</li>
<li>logging的配置方法<ul>
<li>通过代码进行完整配置，主要是通过getLogger方法实现</li>
<li>通过代码进行简单配置，主要是通过basicConfig方法实现</li>
<li>通过配置文件，主要是通过logging.config.fileConfig(filepath)</li>
</ul>
</li>
<li><p>logging用法浅析（getLogger方法）</p>
<ul>
<li>1.初始化 logger = logging.getLogger(“endlesscode”)，getLogger()方法后面最好加上所要日志记录的模块名字，后面的日志格式中的%(name)s 对应的是这里的模块名字</li>
<li>2.设置级别 logger.setLevel(logging.DEBUG),Logging中有NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL这几种级别，日志会记录设置级别以上的日志</li>
<li>3.Handler，常用的是StreamHandler和FileHandler，windows下你可以简单理解为一个是console和文件日志，一个打印在CMD窗口上，一个记录在一个文件上</li>
<li>4.formatter，定义了最终log信息的顺序,结构和内容，比如这样的格式 ‘[%(asctime)s] [%(levelname)s] %(message)s’, ‘%Y-%m-%d %H:%M:%S’。详细说明：<ul>
<li>%(name)s Logger的名字</li>
<li>%(levelname)s 文本形式的日志级别</li>
<li>%(message)s 用户输出的消息</li>
<li>%(asctime)s 字符串形式的当前时间。默认格式是 “2018-02-05 16:49:45,896”。逗号后面的是毫秒</li>
<li>%(levelno)s 数字形式的日志级别</li>
<li>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</li>
<li>%(filename)s 调用日志输出函数的模块的文件名</li>
<li>%(module)s  调用日志输出函数的模块名</li>
<li>%(funcName)s 调用日志输出函数的函数名</li>
<li>%(lineno)d 调用日志输出函数的语句所在的代码行</li>
<li>%(created)f 当前时间，用UNIX标准的表示时间的浮点数表示</li>
<li>%(relativeCreated)d 输出日志信息时的，自Logger创建以来的毫秒数</li>
<li>%(thread)d 线程ID。可能没有</li>
<li>%(threadName)s 线程名。可能没有</li>
<li>%(process)d 进程ID。可能没有</li>
</ul>
</li>
<li>5.记录 使用object.debug(message)来记录日志</li>
<li><p>写一个实例，在窗口上只打出error以上级别的日志，但是在日志中打出debug以上的信息，代码如下：</p>
<pre><code>import logging,sys    
#获取logger实例，如果参数为空则返回root logger
logger=logging.getLogger(&apos;practic&apos;)
logger.setLevel(logging.DEBUG)          #指定日志的最低输出级别，默认为WARN级别
#指定logger输出格式
formatter=logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)-8s - %(message)s&apos;)
#建立一个filehandler来把日志记录在文件里，级别为debug以上
file=logging.FileHandler(&apos;test.log&apos;)
file.setLevel(logging.DEBUG)            #通过setLevel设置日志级别
file.setFormatter(formatter)            #通过setFormatter指定输出格式
#建立一个streamhandler来把日志打在窗口上，级别为error以上
console=logging.StreamHandler(sys.stdout)
console.setLevel(logging.ERROR)
console.formatter=formatter             #也可以直接给formatter赋值
#将相应的handler添加在logger对象中，
logger.addHandler(file)
logger.addHandler(console)
#开始打印日志
logger.debug(&apos;debug信息&apos;)
logger.info(&apos;info信息&apos;)
logger.warning(&apos;warning信息&apos;)
logger.error(&apos;error信息&apos;)
logger.critical(&apos;critical信息&apos;)
</code></pre></li>
</ul>
</li>
<li><p>logging用法浅析（basicConfig方法）</p>
<ul>
<li><p>basicConfig()提供了非常便捷的方式来配置logging模块并马上开始使用</p>
<pre><code>import logging,sys
logging.basicConfig(level=logging.DEBUG,            #定义输出到文件的日志级别
                    format=&apos;%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s %(message)s&apos;,#定义输出格式
                    datefmt=&apos;%a,%d %b %Y %H:%M:%S&apos;) #时间格式
&apos;&apos;&apos;
logging.basicConfig(level=logging.DEBUG,            #定义输出到文件的日志级别
                    format=&apos;%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s %(message)s&apos;,#定义输出格式
                    datefmt=&apos;%a,%d %b %Y %H:%M:%S&apos;, #时间格式
                    filename=&apos;test.log&apos;,            #日志文档名
                    filemode=&apos;a&apos;)                   #写入模式，a为追加，w为覆盖
&apos;&apos;&apos;
logging.debug(&apos;debug信息&apos;)
logging.info(&apos;info信息&apos;)
logging.warning(&apos;warning信息&apos;)
logging.error(&apos;error信息&apos;)
logging.critical(&apos;critical信息&apos;)
</code></pre></li>
</ul>
</li>
<li><p>logging用法浅析（通过文件配置logging）</p>
<ul>
<li>该方法可以参考大神佳作<a href="http://blog.csdn.net/langb2014/article/details/53397164" target="_blank" rel="noopener">python的logging日志模块(一)</a></li>
</ul>
</li>
</ul>
<h6>自定义封装，优化getLogger方法</h6>

<pre><code>import logging,os
class Logger:
    def __init__(self, path,clevel = logging.DEBUG,Flevel = logging.DEBUG):
        self.logger = logging.getLogger(path)
        self.logger.setLevel(logging.DEBUG)
        fmt = logging.Formatter(&apos;[%(asctime)s] [%(levelname)s] %(message)s&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)
        #设置CMD日志
        sh = logging.StreamHandler()
        sh.setFormatter(fmt)
        sh.setLevel(clevel)
        #设置文件日志
        fh = logging.FileHandler(path)
        fh.setFormatter(fmt)
        fh.setLevel(Flevel)
        self.logger.addHandler(sh)
        self.logger.addHandler(fh)
    def debug(self,message):
        self.logger.debug(message)
    def info(self,message):
        self.logger.info(message)
    def war(self,message):
        self.logger.warn(message)
    def error(self,message):
        self.logger.error(message)
    def cri(self,message):
        self.logger.critical(message)
if __name__ ==&apos;__main__&apos;:
    logyyx=Logger(&apos;test.log&apos;,logging.ERROR,logging.DEBUG)
    logyyx.debug(&apos;一个debug信息&apos;)
    logyyx.info(&apos;一个info信息&apos;)
    logyyx.war(&apos;一个warning信息&apos;)
    logyyx.error(&apos;一个error信息&apos;)
    logyyx.cri(&apos;一个致命critical信息&apos;)
#每次使用的时候只要实例化一个对象就可以了
logobj = Logger(&apos;008&apos;,logging.ERROR,logging.DEBUG)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/02/日志Logging/" data-id="cjfclw98k004ha0wv2xhwks2p" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-迭代器、生成器、异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/01/迭代器、生成器、异常/" class="article-date">
  <time datetime="2018-02-01T13:05:40.000Z" itemprop="datePublished">2018-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/01/迭代器、生成器、异常/">迭代器、生成器、异常</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>迭代器、生成器、异常</h5><p></p>
<hr>
<hr>
<p></p><h6>初识迭代器</h6><p></p>
<ul>
<li><p>容器，是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个的迭代获取，可以用in，not in关键字判断元素是否包含在容器中<br>通常这类数据结构把所有的元素存储在内存中（也有特例，并不是所有的元素都放在内存中，比如迭代器、生成器对象）<br>在Python中，常见的容器对象有：list、set、dict、tuple、str、file、sockets等，这些对象都可以看作是容器，容器都可以迭代，因此它们被称为可迭代对象</p>
<pre><code>m=(&apos;a&apos;,1,2,&apos;b&apos;)        #询问某元素是否在元组中，这个元组可以认为是一个容器
print(&apos;a&apos; in m)        #result:True
</code></pre></li>
<li><p>可迭代对象，可直接作用于for循环的对象统称为可迭代对象，即iterable。可迭代对象实现了__iter__方法，该方法返回一个迭代器对象</p>
</li>
<li><p>迭代器，被next()函数调用并不断返回下一个值（直到没有数据时抛出StopIteration错误）的对象称为迭代器，即iterator<br>迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以便下次迭代时获取正确的元素</p>
<pre><code>m=[1,2,3]            #m为可迭代对象
print(type(m))       #result:&lt;class &apos;list&apos;&gt;
m=iter(m)            #iter(可迭代对象)，将可迭代对象转换成迭代器
n=iter(m)            #m与n是两个独立的迭代器，每转换一次就生成一次迭代器
print(type(m))       #result:&lt;class &apos;list_iterator&apos;&gt;
print(next(m))       #result:1
print(next(m))       #result:2  两个next()之间可以增加其他逻辑，但不会影响迭代器输出结果
</code></pre></li>
</ul>
<p></p><h6>详细了解迭代器</h6><p></p>
<ul>
<li>它是一个带状态的对象，它能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()方法的对象都是迭代器<br>__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多的值，则抛出StopIteration异常<br>迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回</li>
<li><p>自己创建一个迭代器，以斐波那契数列为例</p>
<pre><code>#第一个版本，复用性较差
def Fibo(max):          #输出斐波那契数列前N个数
    n,a,b=0,0,1
    while n&lt;max:
        print(b)
        a,b=b,a+b
        n+=1
Fibo(5)                 #result:1  1  2  3  5

#第二个版本，要提高复用性最好不要直接打印出数列，而是返回一个数列
def Fibo(max):
    n,a,b=0,0,1
    L=[]
    while n&lt;max:
        L.append(b)
        a,b=b,a+b
        n+=1
    return L           #返回一个数列
for i in Fibo(5):
    print(i)           #result:1  1  2  3  5
#第三个版本，返回数列能满足复用性的需求，但是运行时占用的内存会随着参数max的增大而增大，如果要控制内存占用，最好不要用List来保存中间结果，而是通过iterable对象来迭代

class Fibo(object):
    def __init__(self,max):
        self.max=max
        self.n,self.a,self.b=0,0,1
    def __iter__(self):
        return self
    def __next__(self):
        if self.n&lt;self.max:
            r=self.b
            self.a,self.b=self.b,self.a+self.b
            self.n+=1
            return r
        raise StopIteration()
f=Fibo(5)
for i in f:
    print(i)            #result:1  1  2  3  5
</code></pre></li>
<li><p>生成器（generator）<br>生成器是一种特殊的迭代器，不需要写__iter__()和__next__()方法，只需要一个关键字yield<br>任何生成器都是以一种懒加载的模式生成值</p>
<pre><code>#第四个版本，如果既要简洁，又要获得iterable的效果，yield就派上用场了
def Fibo(max):
    n,a,b=0,0,1
    while n&lt;max:
        yield b         #使用yield返回值
        a,b=b,a+b
        n+=1
f = Fibo(5)
for i in f:
    print(i)            # result:1  1  2  3  5
</code></pre></li>
</ul>
<p></p><h6>异常</h6><p></p>
<ul>
<li><p>异常：运行时异常，编译时异常，逻辑错误</p>
<pre><code>#运行时异常
a=100
c=0
try:                            #有可能发生异常的代码
    b=int(input(&apos;请输入除数:&apos;))
    c=a/b
    print(c)   
except ZeroDivisionError as m:  #Exception（异常类型1，异常类型2），常见的有ZeroDivisionError、ValueError
    print(m)                    #捕获并处理异常   #result:如果除数为0，则抛出division by zero
except ValueError as n:
    print(n)                    #result:如果除数为字符，则抛出invalid literal for int()
except Exception as p:
    print(p)
else:                           #没有异常才会执行的代码
    print(&apos;程序正常执行!&apos;)
finally:                        #最终要执行的代码，释放资源的作用
    try:                        #异常可以嵌套
        del a,b,c
    except Exception as q:
        print(q)
    print(&apos;程序最终执行完成!&apos;)

#自定义异常
class SexException(Exception):
    pass
def inputSex():
    sex=input(&apos;请输入性别:&apos;)
    if sex!=&apos;男&apos; and sex!=&apos;女&apos;:
        raise SexException(&apos;性别只能是男或者女&apos;)
    print(&apos;输入的性别为&apos;,sex)
try:
    inputSex()
except SexException as m:
    print(m)
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/01/迭代器、生成器、异常/" data-id="cjfclw99f0054a0wvq97as9jv" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-工厂类、单例、其他" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/01/工厂类、单例、其他/" class="article-date">
  <time datetime="2018-02-01T07:33:58.000Z" itemprop="datePublished">2018-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/01/工厂类、单例、其他/">工厂类、单例、其他</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>工厂类、单例、其他</h5><p></p>
<hr>
<hr>
<h6>工厂类、单例模式</h6>

<ul>
<li><p>通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类 并且重写父类方法</p>
<pre><code>class  Operation:
    def __init__(self,numA,numB):
        self.numA=numA
        self.numB=numB
    def getResult(self):
        print(&apos;计算2个操作数的运算结果&apos;)

class Add(Operation):
    def __init__(self,numA,numB):
        super(Add, self).__init__(numA,numB)
    def getResult(self):
        return self.numA+self.numB
class Minus(Operation):
    def __init__(self,numA,numB):
        super(Minus, self).__init__(numA,numB)
    def getResult(self):
        return self.numA-self.numB

class Factory:            #根据不同的参数，创建不同的对象的函数
    def create_class(self,ope,numA,numB):
        if ope == &apos;+&apos;:
            q = Add(numA, numB)
        elif ope == &apos;-&apos;:
            q = Minus(numA, numB)
        else:
            print(&apos;输入错误！&apos;)
        return q

if __name__==&apos;__main__&apos;:
    factory=Factory()             #创建一个工厂对象
    numA=int(input(&apos;请输入第一个数:&apos;))
    numB=int(input(&apos;请输入第二个数:&apos;))
    ope=input(&apos;请输入运算符:&apos;)
    q=factory.create_class(ope,numA,numB)  #代表一个计算器
    print(&apos;计算结果:&apos;,q.getResult())
</code></pre></li>
</ul>
<h6>单例模式</h6>

<ul>
<li><p>该模式的主要目的是确保某一个类只有一个实例存在</p>
<pre><code>class singleton:
    __instance=None
    def __new__(cls, *args, **kwargs):   #单例模式，一个对象
        if cls.__instance==None:
            cls.__instance=object.__new__(cls)
            return cls.__instance
        else:
            return cls.__instance
s1=singleton()
s2=singleton()
print(id(s1),id(s2))       #result:2489344543992   2489344543992
</code></pre></li>
</ul>
<h6>isinstance()函数</h6>

<ul>
<li><p>判断是否是继承关系，判断变量的数据类型</p>
<pre><code>class Pet:
    def look(self):
        print(&apos;给宠物看病...&apos;)
class cat(Pet):
    def look(self):
        print(&apos;给猫咪吃药、打针...&apos;)
kitty=cat()
print(isinstance(kitty,cat))      #result:True
print(isinstance(kitty,Pet))      #result:True

a=&apos;Liu&apos;
print(isinstance(a,str))          #result:True
</code></pre></li>
</ul>
<h6>getattribute\setsttr\hasattr</h6>

<pre><code>class  Operation:
    numC=333
    def __init__(self,numA,numB):
        self.numA=numA
        self.numB=numB
    def getResult(self):
        print(&apos;计算2个操作数的运算结果&apos;)
q=Operation(3,6)
print(Operation.numC)                 #result:333
print(q.__getattribute__(&apos;numC&apos;))     #result:333

q.__setattr__(&apos;numD&apos;,666)
print(q.__getattribute__(&apos;numD&apos;))     #result:666

setattr(Operation,&apos;numE&apos;,999)
print(q.numE)                         #result:999

print(hasattr(q,&apos;numC&apos;))              #result:True
</code></pre><p></p><h6>操作对象的形态</h6><p></p>
<ul>
<li><p>给类动态添加方法</p>
<pre><code>class Student:
    def __init__(self,name):
        self.name=name
    def look(self):
        print(&apos;%s在看书...&apos;%self.name)
def ride(name):
    print(&apos;%s在骑马...&apos;%name)
stu1=Student(&apos;刘备&apos;)
stu1.look()               #result:刘备在看书...

stu1.ride=ride            #给实例添加一个方法
stu1.ride(stu1.name)      #result:刘备在骑马...

class Student:
    def __init__(self,name):
        self.name=name
    def look(self):
        print(&apos;%s在看书...&apos;%self.name)
def ride(self):
    print(&apos;%s在骑马...&apos;%self.name)
Student.ride=ride         #给类动态添加方法
stu1=Student(&apos;刘备&apos;)
stu1.look()               #result:刘备在看书...
stu1.ride()               #result:刘备在骑马...
</code></pre></li>
<li><p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性</p>
<pre><code>class Student:
    __slots__=(&apos;name&apos;)   #限制该class实例能添加的属性
    def __init__(self,name):
        self.name = name
    def look(self):
        print(&apos;%s在看书...&apos;%self.name)
stu=Student(&apos;刘禅&apos;)
stu.look()
stu.age=25
print(stu.age)       #AttributeError: &apos;Student&apos; object has no attribute &apos;age&apos;
</code></pre></li>
<li><p>__call__,通过callable()函数，可以判断一个对象是否是“可调用”对象</p>
<pre><code>class Student:
    def __init__(self,name):
        self.name = name
    def look(self):
        print(&apos;%s在看书...&apos;%self.name)
    def __call__(self, *args, **kwargs):
        #print(&apos;AAAAAAAAAAAAA&apos;)
stu=Student(&apos;刘禅&apos;)
stu.look()
print(callable(stu))         #result:True
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/01/工厂类、单例、其他/" data-id="cjfclw9840047a0wvf03v3o2u" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-计算器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/计算器/" class="article-date">
  <time datetime="2018-01-31T09:38:33.000Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/计算器/">计算器</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <h5>计算器</h5>

<pre><code>class  Operation:
    def __init__(self,numA,numB):
        self.numA=numA
        self.numB=numB
    def getResult(self):
        print(&apos;计算2个操作数的运算结果&apos;)

class Add(Operation):
    def __init__(self,numA,numB):
        super(Add, self).__init__(numA,numB)
    def getResult(self):
        return self.numA+self.numB
class Minus(Operation):
    def __init__(self,numA,numB):
        super(Minus, self).__init__(numA,numB)
    def getResult(self):
        return self.numA-self.numB
class Multiply(Operation):
    def __init__(self,numA,numB):
        super(Multiply, self).__init__(numA,numB)
    def getResult(self):
        return self.numA*self.numB
class Devide(Operation):
    def __init__(self,numA,numB):
        super(Devide, self).__init__(numA,numB)
    def getResult(self):
        return self.numA//self.numB
if __name__==&apos;__main__&apos;:             #程序从这里启动
    numA=int(input(&apos;请输入第一个数:&apos;))
    numB=int(input(&apos;请输入第二个数:&apos;))
    ope=input(&apos;请输入运算符:&apos;)
    q=None      #未赋值的变量，代表一个计算器，类似一个对象
    if ope==&apos;+&apos;:
        q=Add(numA,numB)
    elif ope==&apos;-&apos;:
        q=Minus(numA,numB)
    elif ope==&apos;*&apos;:
        q=Multiply(numA,numB)
    elif ope==&apos;/&apos;:
        q=Devide(numA,numB)
    else:
        print(&apos;输入错误！&apos;)
    print(&apos;计算结果:&apos;,q.getResult())
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/31/计算器/" data-id="cjfclw99f0052a0wvzpmdsapt" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-DVD管理系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/29/DVD管理系统/" class="article-date">
  <time datetime="2018-01-29T09:50:37.000Z" itemprop="datePublished">2018-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/29/DVD管理系统/">DVD管理系统</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <h5>DVD管理系统</h5>

<pre><code>class dvd:
    def __init__(self,name,price,status):
        self.name=name
        self.price=price
        self.status=status
    def __str__(self):
        stat=&apos;已借出&apos;
        if self.status==1:
            stat=&apos;未借出&apos;
        return &apos;名称：《%s》  单价：%d  状态：%s&apos;%(self.name,self.price,stat)
class DvdManage:
    dvds=[]  #存储  多个dvds，每个元素都是一个DVD
    def init(self):
        self.dvds.append(dvd(&apos;光辉岁月&apos;,10,0))
        self.dvds.append(dvd(&apos;大海日出&apos;,12,1))
        self.dvds.append(dvd(&apos;你好小明&apos;,20,1))
    def Menu(self):
        self.init()
        while(True):
            print(&apos;1.查询所有DVD&apos;)
            print(&apos;2.增加DVD&apos;)
            print(&apos;3.借出DVD&apos;)
            print(&apos;4.归还DVD&apos;)
            print(&apos;5.退出&apos;)
            choose=int(input(&apos;请选择操作项:&apos;))
            if choose==1:
                self.showAlldvd()
            elif choose==2:
                self.insertDvd()
            elif choose==3:
                self.lend()
            elif choose==4:
                self.backDvd()
            elif choose==5:
                print(&apos;5.谢谢使用！&apos;)
                break
    def showAlldvd(self):
        for d in self.dvds:
            print(str(d))
    def insertDvd(self):
        name = input(&apos;请输入DVD的名称:&apos;)
        ret=self.checkDvd(name)
        if ret!=None:
            print(&apos;DVD已存在!&apos;)
        else:
            price=int(input(&apos;请输入价格:&apos;))
            new_dvd=dvd(name,price,1)
            self.dvds.append(new_dvd)
            print(&apos;存放成功!&apos;)
    def lend(self):
        name = input(&apos;请输入DVD的名称:&apos;)
        ret = self.checkDvd(name)
        if ret != None:
            if ret.status==0:
                print(&apos;DVD已借出!&apos;)
            else:
                days=int(input(&apos;请输入借出天数:&apos;))
                ret.status=0
                print(&apos;借出%d天，应收%d&apos;%(days,ret.price*days))
        else:
            print(&apos;DVD不存在!&apos;)
    def backDvd(self):
        name=input(&apos;请输入DVD的名称:&apos;)
        ret=self.checkDvd(name)
        if ret==None:
            print(&apos;DVD不存在!&apos;)
        else:
            if ret.status==1:
                print(&apos;DVD未借出!&apos;)
            else:
                days=int(input(&apos;请输入借出天数:&apos;))
                y_money=ret.price * days
                print(&apos;借出%d天，应收%d&apos; % (days, ret.price * days))
                money=0
                while True:
                    money=int(input(&apos;实收:&apos;))
                    if money&lt;y_money:
                        print(&apos;不够啊!&apos;)
                    else:
                        break
                if money&gt;=y_money:
                    print(&apos;找零:%d&apos;%(money-y_money))
                ret.status=1
                print(&apos;归还成功!&apos;)
    def checkDvd(self,name):
        for d in self.dvds:
            if d.name==name:
                return d       #返回当前对象---内存地址
        else:
            return None
manager=DvdManage()
manager.Menu()
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/29/DVD管理系统/" data-id="cjfclw92x0008a0wvs2ifvf8q" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-封装、继承、多态" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/28/封装、继承、多态/" class="article-date">
  <time datetime="2018-01-28T08:40:03.000Z" itemprop="datePublished">2018-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/28/封装、继承、多态/">封装、继承、多态</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>封装、继承、多态</h5><p></p>
<hr>
<hr>
<p></p><h6>封装</h6><p></p>
<ul>
<li><p>隐藏内部实现，提供外部接口<br>两个步骤：属性私有化——set\get函数写方法</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age
    @property
    def age(self):
        return self.__age
    @age.setter
    def age(self,value):
        if value&lt;0 or value&gt;100:
            self.__age=18
        else:
            self.__age=value
m=Student(&apos;刘桑&apos;,25)
m.age=100
print(m.age)              #result:100
</code></pre></li>
</ul>
<p></p><h6>继承</h6><p></p>
<ul>
<li><p>继承：子类继承父类，子类可以使用父类的属性和方法，简化代码<br>子类继承父类，父类派生子类（父类又叫基类，子类又叫派生类）<br>继承指出两个类符合“A是B”的关系</p>
<pre><code>class Vehicle:         #交通工具类
    def __init__(self,name):
        self.name=name
        print(&apos;交通工具被初始化！&apos;)
    def run(self):
        print(&apos;交通工具在行驶...&apos;)
    def show(self):
        print(&apos;车的名字是%s&apos;%self.name)
class Truck(Vehicle):    #卡车，属性：载重
    #当子类继承父类时，子类的构造方法应该包含父类和子类共有的属性，如name
    #在子类的初始化方法中，将父类的属性传递给父类，子类的属性赋值给子类
    #在子类的初始化方法中，调用父类的属性有四种方法：
    # 1，父类名.属性 2，self.属性 3，父类名.__init__(self,属性) 4，super(子类名,self).__init__(属性)
    def __init__(self,name,weight):
        #Vehicle.name=name                 #1，父类名.属性
        #self.name=name                    #2，self.属性
        #Vehicle.__init__(self,name)       #3，父类名.__init__(self,属性)
        super(Truck,self).__init__(name)   #4，super(子类名,self).__init__(属性)
        self.weight=weight
        print(&apos;卡车被初始化！&apos;)
    def run(self):        #卡车，重写行驶方法
        #super().show() #调用父类方法
        #Vehicle.show(self)
        super(Truck,self).show()
        print(&apos;%s卡车载重%d吨在行驶...&apos;%(self.name,self.weight))
class Train(Vehicle):     #火车，属性：车厢个数
    def __init__(self,name,nums):
        self.nums=nums
    def run(self):        #火车，重写行驶方法
        print(&apos;火车在轨道行驶...&apos;)

t=Truck(&apos;解放&apos;,25)
t.run()
</code></pre></li>
<li><p>三代继承：子类初始化方法需祖父、父类及自己的属性，可以调用父类的初始化方法传参，可以重写父类的方法，构造的顺序依然先构造祖父类，再构造父类，最后构造自己</p>
</li>
<li><p>多继承：一个类同时继承多个父类，class(A,B),当AB均有相同方法，而子类又重写时，调用子类的方法；如果子类没有方法，则调用优先继承的类</p>
<h6>多态</h6></li>
<li>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用</li>
<li><p>多态就是多种表现形态的意思。它是一种机制、一种能力，而非某个关键字。它在类的继承中得以实现，在类的方法调用中得以体现。多态意味着变量并不知道引用的对象是什么，根据引用对象的不同表现不同的行为方式</p>
<pre><code>class Pet:
    def look(self):
        print(&apos;给宠物看病...&apos;)
class cat(Pet):
    def look(self):
        print(&apos;给猫咪吃药、打针...&apos;)
class dog(Pet):
    def look(self):
        print(&apos;给小狗打针、输液...&apos;)
class bird(Pet):
    def look(self):
        print(&apos;给小鸟输液、疗养...&apos;)
class Doctor:
    def jiuzhen(self,Pet):        #传参的时候达到了多态
        print(&apos;兽医出诊，给宠物看病...&apos;)
        Pet.look()
class person:
    def look(self):
        print(&apos;给人类看病...&apos;)

longmao=cat()
dahu=dog()
yingwu=bird()
xiaoming=person()
#longmao.look()
#dahu.look()
#yingwu.look()
doctor=Doctor()
doctor.jiuzhen(longmao)     #result:兽医出诊，给宠物看病..   给猫咪吃药、打针...
doctor.jiuzhen(dahu)        #result:兽医出诊，给宠物看病..   给小狗打针、输液...
doctor.jiuzhen(yingwu)      #result:兽医出诊，给宠物看病..   给小鸟输液、疗养...
doctor.jiuzhen(xiaoming)    #result:兽医出诊，给宠物看病..   给人类看病...
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/28/封装、继承、多态/" data-id="cjfclw98k004ea0wvvfa3fq4r" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-类与对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/22/类与对象/" class="article-date">
  <time datetime="2018-01-22T09:23:16.000Z" itemprop="datePublished">2018-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/22/类与对象/">类与对象</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>类与对象</h5><p></p>
<hr>
<hr>
<p></p><h6>基础定义</h6><p></p>
<ul>
<li><p>在python中，一个对象的特征也称为属性（attribute），它所具有的行为也称为方法（method），把具有相同属性和方法的对象归为一个类（class）。即类就是具有相同属性和方法的对象的集合</p>
<pre><code>class Student:
    &apos;&apos;&apos;
    学生类             #文档说明，可通过类名.__doc__访问
    &apos;&apos;&apos;
    #类的成员：特性  行为
    pass              #保证语义的完整
</code></pre></li>
<li><p>类名规范：首字母大写，以大写字母分割单词，不使用下划线;不允许使用数字、关键字、除下划线以外的特殊字符开头<br><br>属性名规范：使用名词，首字母小写，以大写字母分割单词<br><br>方法名规范：使用谓词（动词+对象），首字母小写，以大写字母分割单词<br></p>
<pre><code>class Student:
    def __init__(self,name,age):    
    #__init__()这个方法会在创建对象时完成初始化，并把类的属性绑上去
        self.name=name           #创建对象属性
        self.age=age
    def showName(self):   #self对象的载体
        print(&apos;我叫{}!&apos;.format(self.name))        
m=Student(&apos;张三&apos;,27)
m.showName()
</code></pre></li>
<li><p>属性分归属：对象属性、类属性<br>对象属性有两种创建方式</p>
<pre><code>#第一种方式，初始化时添加对象属性
class Student:
    def __init__(self,name,age):    
        self.name=name           #创建对象属性
        self.age=age
    def showName(self):   
        print(&apos;我叫{}!&apos;.format(self.name))        
m=Student(&apos;张三&apos;,27)
m.showName()

#第二种方式，赋值的形式
class Student:
    def showName(self):
        print(&apos;我叫{}!&apos;.format(self.name))
n=Student()
n.name=&apos;李四&apos;                    #对象名.属性 
n.showName()
</code></pre></li>
<li><p>类属性的创建、修改</p>
<pre><code>#类属性，属于类的成员，对象共有的,类属性也可以如下创建
class Student:
    ablity=&apos;study&apos;             #在类里直接写：attr=value
#类属性修改方式：类名.类属性=xxx  或者 实例对象.__class__类属性=xxx
</code></pre><p>  <em>关于类属性与对象属性的区别可参考<a href="http://python.jobbole.com/85100/" target="_blank" rel="noopener">关于Python类属性与实例属性的讨论</a></em></p>
</li>
<li><p>__new__()<br>定义一个类时，如果使用__init__函数来设置类具有的属性，实际上最先执行__new__函数，通过该函数，返回一个类的实例，故而init函数才有self参数</p>
<pre><code>class Student:
    def __new__(cls, *args, **kwargs):
        return object.__new__(cls)
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def showName(self):
        print(&apos;我叫{}!&apos;.format(self.name))
m=Student(&apos;张三&apos;,27)
m.showName()
</code></pre></li>
<li><p>对象属性的公有、私有<br>如果有一些属性不想给外部权限来访问或者修改，可以在属性或者方法的名字前加双下划线，声明为私有属性；私有属性只能在当前类中使用</p>
<pre><code>#如只给外部访问的权限，不给修改的权限，可以在类里定义一个返回属性的函数
class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age         #在属性名字前加双下划线，声明为私有属性
    def get_Age(self):
        return self.__age
m=Student(&apos;刘桑&apos;,25)
print(m.get_Age())              #result:25
&apos;&apos;&apos;
#给与外部访问与修改权限，但修改值应按照设计的范围来
class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age         #在属性名字前加双下划线，声明为私有属性
    def get_Age(self):
        return self.__age
    def set_Age(self,age):
        if age&lt;0 or age&gt;100:
            self.__age=18   #给一个默认值
        else:
            self.__age=age
m=Student(&apos;刘桑&apos;,25)
m.set_Age(100)
print(m.get_Age())              #result:100
</code></pre></li>
<li><p>注解@property的使用<br>它的作用是将一个函数作为类的一个属性来访问，或者把一个getter方法变成属性，@属性名.setter把setter方法变成属性赋值</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age
    #先定义两个函数，函数名为属性名，第一个函数返回属性值，第二个函数修改属性值
    @property               #在第一个函数头上写@property
    def age(self):
        return self.__age
    @age.setter             #在第二个函数头上写@属性名.setter
    def age(self,value):
        if value&lt;0 or value&gt;100:
            self.__age=18   #给一个默认值
        else:
            self.__age=value
m=Student(&apos;刘桑&apos;,25)
m.age=100
print(m.age)              #result:100
</code></pre></li>
<li><p>对象方法的公有、私有<br>私有方法在方法前加双下划线；私有方法只能在当前类中使用</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age
    def __showInfo(self):    #私有方法在方法前加双下划线
        return &apos;My name is&apos;+self.name
m=Student(&apos;刘桑&apos;,100)
print(m.__showInfo())       #result:AttributeError
</code></pre></li>
<li><p>类方法、静态方法<br>类方法，在方法前添加@classmethod装饰器，可通过类、对象调用<br>静态方法，在方法前添加@staticmethod，参数没有要求，与类、对象没有关系，但可通过类、对象调用</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def instance_method(self):   #实例方法
        print(&apos;实例方法&apos;)
    @classmethod
    def class_method(cls):       #类方法：第一个参数会自动接收类对象，一般用cls
        print(&apos;类方法&apos;)
    @staticmethod
    def static_method():         #静态方法，参数没有要求
        print(&apos;静态方法&apos;)
m=Student(&apos;刘桑&apos;,100)
Student.class_method()           #通过类名调用类方法
m.class_method()                 #通过实例调用类方法

Student.static_method()          #通过类名调用静态方法
m.static_method()                #通过实例调用静态方法
</code></pre></li>
<li><p>__str__()<br>这个方法告诉python在打印一个对象时,具体显示什么内容</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age
    def __str__(self):    #可以重写
        return &apos;My name is&apos;+self.name
m=Student(&apos;刘桑&apos;,100)
print(m)                  #result:My name is刘桑
</code></pre></li>
<li><p>__del__()<br>自动销毁，当对象没有引用或者程序结束的时候，程序自动调用该方法</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age
    def __str__(self):    #可以重写
        return &apos;My name is&apos;+self.name
    def __del__(self):
        print(self.name+&apos;被销毁！&apos;)
m=Student(&apos;刘桑&apos;,100)
                          #result:刘桑被销毁！

#也可以直接使用del m
</code></pre></li>
<li><p>__dir__()<br>用来展示一个类、对象的属性和方法</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.age=age
m=Student(&apos;刘桑&apos;,100)
print(m.__dir__())
</code></pre></li>
<li><p>getrefcount()可返回一个对象有多少个引用，返回2，从2开始</p>
<pre><code>import sys
class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age        
m=Student(&apos;刘桑&apos;,25)
mm=m
print(sys.getrefcount(m))      #result:3
</code></pre></li>
<li><p>_类名__属性名,通过该方式可访问私有属性，一般不建议</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.__age=age
m=Student(&apos;刘桑&apos;,25)
print(m._Student__age)
</code></pre></li>
<li><p>id()<br>对一个对象的引用调用id()函数，可得到该对象的标识符dentity，该标识符是一个int，它保证在该对象的生命周期内是唯一恒定的，具有不重叠生命周期的两个对象具有不同的id值</p>
<pre><code>class Student:
    def __init__(self,name,age):
        self.name=name
        self.age=age
m=Student(&apos;刘桑&apos;,25)
n=Student(&apos;宮某&apos;,25)
print(id(m))                  #result:1832993645624
print(id(n))                  #result:1832993647864
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/22/类与对象/" data-id="cjfclw98z004oa0wvrgeg282l" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/19/函数/" class="article-date">
  <time datetime="2018-01-19T13:47:47.000Z" itemprop="datePublished">2018-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/19/函数/">函数</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>函数</h5><p></p>
<hr>
<hr>
<h6>定义</h6>

<ul>
<li>高复用、低耦合</li>
<li><p>语法</p>
<pre><code>def add(a,b):        #def 函数名(参数列表):
                     #函数体
    return a+b       #可以返回多个值，返回的多个值组成元组；返回值加上中括号，返回列表      
ret=add(1,2)
print(&apos;返回值&apos;,ret)           #result:返回值 3
</code></pre></li>
<li><p>可更改与不可更改对象</p>
<pre><code>def fun(a):
    a=10
    print(&apos;函数内部a为&apos;,a)
a=5
print(&apos;调用前&apos;,a)      #result:调用前 5
fun(a)                #result:函数内部a为 10
print(&apos;调用后&apos;,a)      #result:调用后 5
#在python中，string,tuples,numbers是不可更改的对象，list,dict则是可以修改的对象
#不可变类型：变量赋值a=5后再次赋值a=10，这里实际是新生成一个int值对象10，再让a指向它，而5被丢弃，不是改变a的值；相当于新生成了a
#不可变类型：值传递（复制副本），如fun(a),传递的只是a的值，没有影响a对象本身；如在fun(a)内部修改a的值，只是修改另一个复制的对象，不会影响a本身

def fun(b):
    b[0]=&apos;刘备&apos;
    b[1]=&apos;刘禅&apos;
b=[&apos;刘邦&apos;,&apos;刘秀&apos;]
print(&apos;调用前&apos;,b)      #result:调用前 [&apos;刘邦&apos;, &apos;刘秀&apos;]
fun(b)
print(&apos;调用后&apos;,b)      #result:调用后 [&apos;刘备&apos;, &apos;刘禅&apos;]
#可变类型：变量赋值b=[1,2,3]后再次赋值b[2]=5则是将b的第三个元素值更改，本身b没有动，只是其内部的一部分值被修改了
#可变类型：引用传递(实质是值传递，传递可变类型-可以改变内容，但不可以改变原地址)，如fun(b)，则是将b真正的传过去，修改后fun外部的b也会受影响

def fun(b):
    b=[&apos;刘备&apos;,&apos;刘禅&apos;]
    print(&apos;函数内部b为&apos;,b)
b=[&apos;刘邦&apos;,&apos;刘秀&apos;]
print(&apos;调用前&apos;,b)      #result:调用前 [&apos;刘邦&apos;, &apos;刘秀&apos;]
fun(b)                   #result:函数内部b为 [&apos;刘备&apos;, &apos;刘禅&apos;]
print(&apos;调用后&apos;,b)      #result:调用后 [&apos;刘邦&apos;, &apos;刘秀&apos;]
#相当于不可变类型
</code></pre></li>
</ul>
<h6>参数类型</h6>

<ul>
<li>在Python中定义函数,可用必选参数、默认参数、可变参数、关键字参数、命名关键字参数；除了可变参数无法和命名关键字参数组合使用外，其他均可组合使用；参数定义的顺序必须是：必选参数、默认参数、可变参数/命名关键字参数和关键字参数</li>
<li><p>必选参数（形参与实参的个数、类型、顺序一一对应）</p>
<pre><code>def fun1(a,b):              #形参：定义方法
    &apos;&apos;&apos;
    :param a:               第一个加数
    :param b:               第二个加数
    :return:                和
    &apos;&apos;&apos;
    return a+b
h=fun1(33,66)               #实参：调用方法
print(fun1.__doc__)         #调看文档
print(h)                    #result:99
</code></pre></li>
<li><p>默认参数（缺省参数）须写在后面，可以不指定参数名，但是顺序要正确，否则需要指定参数名</p>
<pre><code>def fun2(a,b=3):
    return a+b
h=fun2(4)
print(h)                    #result:7
</code></pre></li>
<li><p>可变参数（不定长参数）该参数允许传入0个或者任意个参数，这些参数在函数调用时组装为一个tuple</p>
<pre><code>def getSum(*nums):
    sum=0
    for i in nums:
        sum+=i
    return sum
m=[1,2,3,4,5]
n=(1,2,3,4,5)
print(getSum())                  #result:0
print(getSum(1,2,3,4,5,6,7))     #result:28
print(getSum(*m))                #result:15
print(getSum(*n))                #result:15
</code></pre></li>
<li><p>命名关键字参数  该参数允许传入0个或者任意个参数，这些参数在函数内部自动组装为一个dict;一旦以name=value的的传参数的形式存在，之后都要以这种形式存在，但不要求顺序</p>
<pre><code>def show(name,age,score=90):
    print(&apos;姓名{} 年龄{} 成绩{}&apos;.format(name,age,score))
show(name=&apos;Liu&apos;,age=27,score=135)      #result:姓名Liu 年龄27 成绩135
</code></pre></li>
<li><p>关键字参数 该参数允许传入0个或者任意个参数，这些参数在函数内部自动组装为一个dic</p>
<pre><code>def student(name,age,**hobby):
    print(&apos;姓名{} 年龄{} 爱好{}&apos;.format(name,age,hobby))
dic={&apos;一&apos;:111,&apos;二&apos;:222,&apos;三&apos;:333}
student(&apos;Liu&apos;,30,hobby=&apos;Footboll&apos;)     #result:姓名Liu 年龄30 爱好{&apos;hobby&apos;: &apos;Footboll&apos;}
student(&apos;Liu&apos;,30,**dic)                #result:姓名Liu 年龄30 爱好{&apos;三&apos;: 333, &apos;二&apos;: 222, &apos;一&apos;: 111}
</code></pre></li>
<li><p>组合参数 包括若干种参数</p>
<pre><code>def fun1(a,b,c=9,*args,**kw):
    print(&apos;a=&apos;,a,&apos;b=&apos;,b,&apos;c=&apos;,c,&apos;args=&apos;,args,&apos;kw=&apos;,kw)
#*args是可变参数，会这个分割args 逐个对应形参列表
#**kw只能对应到形参列表的**kw
m=(1,2,3,4,5)
n={&apos;一&apos;:111,&apos;二&apos;:222}
fun1(&apos;A&apos;,&apos;B&apos;)                      #result:a= A b= B c= 9 args= () kw= {}
fun1(*m)                           #result:a= 1 b= 2 c= 3 args= (4, 5) kw= {}
fun1(*m,**n)                       #result:a= 1 b= 2 c= 3 args= (4, 5) kw= {&apos;二&apos;: 222, &apos;一&apos;: 111}
</code></pre></li>
</ul>
<h6>变量作用域</h6>

<ul>
<li><p>当全局和局部同名时，优先局部变量</p>
<pre><code>a=10           #全局变量
def changeNum():
    global a
    a=5        #局部变量
    print(&apos;函数内部a为&apos;,a)
print(&apos;调用前a为&apos;,a)              #result:10
changeNum()                      #result:5
print(&apos;调用后a为&apos;,a)              #result:5
</code></pre></li>
</ul>
<h6>匿名函数（lambda）</h6>

<pre><code>sum=lambda a,b:a+b               #定义函数
s=sum(3,9)                       #执行函数
print(s)                         #result:12

def add(a,b,fun):
    &apos;&apos;&apos;
    :param a:
    :param b:
    :param fun:        传递过来的函数
    :return:
    &apos;&apos;&apos;
    print(fun(a,b))              #委托
add(11,22,lambda a,b:a+b)        #result:33

m=int(input(&apos;请输入一个操作数：&apos;))
n=int(input(&apos;请输入一个操作数：&apos;))
fun1=input(&apos;请输入一个函数：&apos;)     #lambda a,b:a+b
fun1=eval(fun1)                  #eval函数将字符串当成有效Python表达式来求值，并返回计算结果
print(fun1(n,m))
</code></pre><p></p><h6>内置函数</h6><p></p>
<ul>
<li><p>filter()通过表达式返回true时保留符合条件的信息</p>
<pre><code>#filter(函数,列表、元组、字典、可迭代的)
foo=[2,18,9,22,17,24,8,12,27]
result=filter(lambda x:x%3==0,foo)
print(list(result))              #result:[18, 9, 24, 12, 27]
</code></pre></li>
<li><p>map()函数接收两个参数，一个是函数，一个是序列，该函数将序列的每个元素传入函数中执行，并把结果作为新的list返回</p>
<pre><code>foo=[1,2,3,4,5]
result=map(lambda x:x+4,foo)
print(list(result))              #result:[5, 6, 7, 8, 9]
</code></pre></li>
<li><p>reduce()对于序列内所有元素进行累计操作，先对序列中的第1、2个数据进行操作，得到的结果再与第三个数据运算，最后得到一个结果；python内置了求和函数sum(),一般用reduce()</p>
</li>
</ul>
<pre><code>import functools            #reduce()函数现在放置在了functools模块里了
foo=[1,2,3,4,5,6,7]
m=functools.reduce(lambda a,b:a+b,foo)
print(m)                    #result:28

foo=[1,2,3,4,5,6,7]
m=functools.reduce(lambda a,b:a+b,foo,100)    #可以接受第三个参数
print(m)                    #result:128

foo=[1,2,3,4,5,6,7]
print(sum(foo))             #result:28
</code></pre><ul>
<li><p>sorted()排序函数，排序时不影响原数据，产生新的排序数据  </p>
<pre><code>ol=[1,3,9,5,2,4]
ul=sorted(ol,reverse=False)
print(ul)            #result:[1, 2, 3, 4, 5, 9]

ol=[1,3,9,5,2,4]
ul=sorted(ol,reverse=True)
print(ul)            #result:[9, 5, 4, 3, 2, 1]

ol=[(&apos;Abot&apos;,98),(&apos;Tom&apos;,57),(&apos;Honey&apos;,77)]
ul=sorted(ol,key=lambda s:s[1],reverse=True)  #key,依据什么来进行排序
print(ul)            #result:[(&apos;Abot&apos;, 98), (&apos;Honey&apos;, 77), (&apos;Tom&apos;, 57)]
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/19/函数/" data-id="cjfclw979003ka0wvt5tn21a9" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django学习/">Django学习</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git学习/">Git学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP协议/">HTTP协议</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux学习/">Linux学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB数据库/">MongoDB数据库</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL学习/">MySQL学习</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python学习/">Python学习</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis数据库/">Redis数据库</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web前端/">Web前端</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全测试/">安全测试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包工具/">抓包工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫学习/">爬虫学习</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化测试/">自动化测试</a><span class="tag-list-count">5</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django学习/" style="font-size: 12.5px;">Django学习</a> <a href="/tags/Git学习/" style="font-size: 13.75px;">Git学习</a> <a href="/tags/HTTP协议/" style="font-size: 10px;">HTTP协议</a> <a href="/tags/Linux学习/" style="font-size: 13.75px;">Linux学习</a> <a href="/tags/MongoDB数据库/" style="font-size: 12.5px;">MongoDB数据库</a> <a href="/tags/MySQL学习/" style="font-size: 15px;">MySQL学习</a> <a href="/tags/Python学习/" style="font-size: 20px;">Python学习</a> <a href="/tags/Redis数据库/" style="font-size: 16.25px;">Redis数据库</a> <a href="/tags/Web前端/" style="font-size: 18.75px;">Web前端</a> <a href="/tags/安全测试/" style="font-size: 12.5px;">安全测试</a> <a href="/tags/性能测试/" style="font-size: 11.25px;">性能测试</a> <a href="/tags/抓包工具/" style="font-size: 11.25px;">抓包工具</a> <a href="/tags/爬虫学习/" style="font-size: 17.5px;">爬虫学习</a> <a href="/tags/自动化测试/" style="font-size: 13.75px;">自动化测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/29/scrapy基础了解/">scrapy基础了解</a>
          </li>
        
          <li>
            <a href="/2018/03/28/网络配置、系统查看/">网络配置、系统查看</a>
          </li>
        
          <li>
            <a href="/2018/03/28/vi-vim/">vi/vim</a>
          </li>
        
          <li>
            <a href="/2018/03/28/linux常用命令/">linux常用命令</a>
          </li>
        
          <li>
            <a href="/2018/03/28/session会话/">session会话</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
       Email:<a>liuyongqian51@163.com</a><br />
          QQ:<a>272501447</a><br />
	  Github:<a></a>
    </div>
  </div>

  
  

</aside>


        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 刘永前<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>

</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>