<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>LiuYongQian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="永远相信美好的事情将要发生！">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongQian">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="LiuYongQian">
<meta property="og:description" content="永远相信美好的事情将要发生！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongQian">
<meta name="twitter:description" content="永远相信美好的事情将要发生！">
  
    <link rel="alternate" href="/atom.xml" title="LiuYongQian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongQian</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">永远相信美好的事情将要发生！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-自动化测试模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/01/自动化测试模型/" class="article-date">
  <time datetime="2018-02-28T23:44:01.000Z" itemprop="datePublished">2018-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/01/自动化测试模型/">自动化测试模型</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>自动化测试模型</h5><p></p>
<hr>
<hr>
<p></p><h6>概述</h6><p></p>
<ul>
<li>自动化测试模型可以看作自动化测试框架与工具设计的思想。自动化测试不仅仅是单纯写写脚本运行就可以了，还需要考虑到如何使脚本运行效率提高，代码复用、参数化等问题</li>
<li>自动化测试模型分为四大类：线性模型，模块化驱动测试、数据驱动、关键词驱动</li>
</ul>
<p></p><h6>线性模型</h6><p></p>
<ul>
<li>线性脚本中每个脚本都相互独立，且不会产生其他依赖与调用，其实就是简单模拟用户某个操作流程的脚本</li>
</ul>
<p></p><h6>模块化驱动测试</h6><p></p>
<ul>
<li>线性模型虽然每个用例都可以拿出来独立运行，但是用例之间重复代码很多，开发、维护成本高。其实把重复的操作代码封装为独立的公共模块，当用例执行时需要用到这部分，直接调用即可，这就是模块驱动的方式。比如登录系统、退出登录、截图函数等等</li>
</ul>
<p></p><h6>数据驱动测试</h6><p></p>
<ul>
<li>模块驱动的模型虽然解决了脚本的重复问题，但是需要测试不同数据的用例时，模块驱动的方式就不很适合了。数据驱动就是数据的改变从而驱动自动化测试的执行，最终引起测试结果的改变</li>
<li><p>装载数据的方式可以是列表、字典或是外部文件（txt、csv、xml、excel），目的就是实现数据和脚本的分离</p>
<pre><code>#文件名：login.py
#coding:utf-8
from selenium import webdriver
from time import sleep
class Login():
    def user_login(self,driver,username,password):
        driver.find_element_by_name(&apos;username&apos;).clear()
        driver.find_element_by_name(&apos;username&apos;).send_keys(username)
        driver.find_element_by_name(&apos;password&apos;).clear()
        driver.find_element_by_name(&apos;password&apos;).send_keys(password)
        driver.find_element_by_name(&apos;Submit&apos;).click()
    def user_logout(self,driver):
        driver.find_element_by_link_text(&apos;退出&apos;).click()
        sleep(2)
        driver.switch_to_alert().accept()

    #模块化与参数化
    from login import *
    from time import sleep
    from selenium import webdriver

    driver=webdriver.Firefox()
    driver.get(&apos;http://localhost&apos;)

    Login().user_login(driver,&apos;51zxw&apos;,&apos;123456&apos;)
    sleep(5)
    Login().user_logout(driver)
    sleep(5)

    Login().user_login(driver,&apos;52zxw&apos;,&apos;123456&apos;)
    sleep(5)
    Login().user_logout(driver)
    sleep(2)

    driver.quit()
</code></pre></li>
</ul>
<p></p><h6>关键字驱动测试</h6><p></p>
<ul>
<li>通过关键字的改变引起测试结果的改变叫关键字驱动测试。 selenium IDE也是一种传统的关键字驱动的自动化工具，Robot Framework 是一个功能更强大的关键字驱动测试框架</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/01/自动化测试模型/" data-id="cjfji2ui30050agwvojlsfolw" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Jmeter基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/28/Jmeter基础/" class="article-date">
  <time datetime="2018-02-28T15:10:23.000Z" itemprop="datePublished">2018-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/Jmeter基础/">Jmeter基础</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>Jmeter基础</h5><p></p>
<hr>
<hr>
<p></p><h6>Jmeter简介</h6><p></p>
<ul>
<li>Apache Jmeter是Apache组织的开放源代码项目，是一个纯Java桌面应用，用于分析不同压力条件下的总体性能情况，也可以使用Jmeter提供的图形化界面分析性能指标或者在高负载情况下测试服务器、脚本、对象</li>
<li>Jmeter与LR的主要区别在于Jmeter不提供IP欺骗技术</li>
<li>Jmeter安装配置<ul>
<li>安装配置好jdk后，解压apache-jmeter-4.0，运行bin目录下的ApacheJMeter.jar</li>
</ul>
</li>
<li>Jmeter文件目录介绍<ul>
<li>bin可执行文件目录<ul>
<li>jmeter.bat windows的启动文件</li>
<li>jmeter.sh linux的启动文件</li>
<li>jmeter.properties 系统配置文件</li>
<li>jmeter-server.bat Windows分布式测试要用到的服务器配置</li>
<li>jmeter-server linux分布式测试要用到的服务器配置</li>
</ul>
</li>
<li>docs接口文档目录</li>
<li>lib所用到的插件目录</li>
<li>License Jmeter证书目录</li>
<li>printable_docs用户使用手册</li>
</ul>
</li>
<li>功能概要<ul>
<li>Jmeter工具组成部分<ul>
<li>资源生成器：用于生成测试过程中服务器、负载机的资源代码（VuGen）</li>
<li>用户运行器：根据脚本要求模拟指定的用户行为（Controller）</li>
<li>报表生成器：根据测试中实时的数据生成报表，提供可视化的数据显示形式（Analysis）</li>
<li>负载发生器：用于产生负载，通常以多线程、多进程的方式模拟用户行为（Load Generater）</li>
<li>测试计划：相当于lr的一个测试场景</li>
</ul>
</li>
<li>Threads(Users)线程  用户<ul>
<li>a.setup thread group,可用于执行预测试操作，类似lr的init()</li>
<li>b.teardown thread group，可用于执行测试后动作，类似lr的end()</li>
<li>c.Thread group，这个就是通常运行的线程，类似lr的action()</li>
</ul>
</li>
<li>线程组的8类可执行文件<ul>
<li>配置元件（cinfig element）用于提供对静态数据配置的支持</li>
<li>定时器（Timer）类似于lr中的思考时间</li>
<li>前置处理器（per processors）用于在实际的请求发出前对即将发出的请求进行特殊处理</li>
<li>后置处理器（post processors）类似于lr中的关联概念</li>
<li>断言（assertions）用于检查测试中得到的相应数据是否符合预期</li>
<li>监听器（listener）用来对测试结果数据进行处理和可视化展示的一系列元件，这个监听器可不是用来监听系统资源的元件</li>
<li>取样器（sample）是性能测试中向服务器发送请求，记录相应信息，记录响应时间的最小单元</li>
<li>逻辑控制器（logic controller）包括两类元件，一类是用于控制测试计划中sampler节点发送请求的逻辑顺序控制器，常用的有if控制器、循环控制器等，另一类是用来组织可控制sampler节点的，如事务控制器，吞吐量控制器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><h6>脚本录制</h6><p></p>
<ul>
<li>Badboy脚本录制完成后，导出为Export to jmeter</li>
<li>Badboy检查点设置</li>
<li>Badboy参数化</li>
</ul>
<p></p><h6>元件作用域、执行顺序</h6><p></p>
<ul>
<li>元件作用域<ul>
<li>8类可被执行的元件（测试计划与线程组不属于可执行元件），这些元件中，取样器是典型的不与其他元件发生交互作用的元件，逻辑控制器只对其子节点的取样器有效，而其他元件需要与取样器等元件交互</li>
<li>在Jmeter中，元件的作用域是靠测试计划的树型结构中元件的父子关系来确定的，作用域的原则是：<ul>
<li>a，取样器元件不和其他元件相互作用，因此不存在作用域的问题</li>
<li>b，逻辑控制器元件只对其子节点中的取样器和逻辑控制器作用</li>
<li>c，除取样器和逻辑控制器元件外，其他6类元件，如果是某个取样器的子节点，则该元件对其父子节点起作用，如果其父节点不是取样器，则其作用域是该元件父节点下的其他所有后代节点（包括子节点，子节点的子节点等）</li>
</ul>
</li>
</ul>
</li>
<li>元件执行顺序<ul>
<li>配置元件–前置处理程序–定时器–取样器–后置处理程序–断言–监听器<ul>
<li>注意：前置处理器、后置处理器和断言等元件功能对取样器作用，因此，如果在他们的作用域内没有任何取样器，则不会被执行；如果在同一作用域内有多个同一类型的元件，则这些元件按照他们在测试计划中的上下顺序依次执行</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/28/Jmeter基础/" data-id="cjfji2ucg0010agwv4savqjis" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能测试/">性能测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-初识MySQL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/28/初识MySQL/" class="article-date">
  <time datetime="2018-02-28T10:08:48.000Z" itemprop="datePublished">2018-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/28/初识MySQL/">初识MySQL</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>初识MySQL</h5><p></p>
<hr>
<hr>
<p></p><h6>基础</h6><p></p>
<ul>
<li>数据库就是“数据”的“仓库”,包含表、关系以及操作对象,数据存放在表中</li>
<li>MySQL的优势：运行速度快、使用成本低、可移植性强、适用用户广</li>
<li><p>安装目录下主要文件夹</p>
<pre><code>bin：客户端程序和服务器
data：临时数据存放，日志文件，数据库
include:导入，需要里面这些文件，包含（头）文件
lib:组件
share:错误消息文件
</code></pre></li>
<li><p>DOS下运行mysql</p>
<pre><code>net start mysql
mysql -h服务器主机地址（本地可省略） -u用户名 -p密码
create database 数据库名;         #创建数据库
show databases;                  #查看数据库
use数据库;                         #选择数据库
drop database 数据库名;              #删除数据库

create table if not exists 表名(
    studentNo INT(4) NOT NULL COMMENT&apos;学号&apos; PRIMARY KEY,
    ...
)comment=&apos;表名&apos;
show tables;                    #查看表是否存在
desc 表名;                     #查看表定义
drop table if exists 表名;      #删除表
</code></pre></li>
<li>SQL结构化查询语言<ul>
<li>DML(数据操作语言)用来操作数据库中所包含的数据，命令：insert、update、delete</li>
<li>DDL（数据定义语言）用来创建和删除数据库对象等操作，命令：create、drop、alert</li>
<li>DQL（数据查询语言）用来对数据库中的数据进行查询，命令：select</li>
<li>DCL（数据控制语言）用来控制数据库组件的存取许可、存取权限等，命令：grant、commit、rollback</li>
</ul>
</li>
<li>SQL中的运算符<ul>
<li>算术运算符，用来进行列间或者变量之间的比较和数学运算<ul>
<li>+加、-减、*乘、/除、%取余</li>
</ul>
</li>
<li>赋值运算符，把一个数或者变量或者表达式赋值给另一个变量，如Name=’刘桑’<ul>
<li>=赋值</li>
</ul>
</li>
<li>逻辑运算符<ul>
<li>and 当且仅当两个布尔表达式都为true时，返回true</li>
<li>or 当且仅当两个布尔表达式都为false时，返回false</li>
<li>not布尔表达式的值取反</li>
</ul>
</li>
<li>比较运算符<ul>
<li>=等于、&gt;大于、&lt;小于、&lt;&gt;不等于、&gt;=大于等于、&lt;=小于等于、!=不等于（非SQL-92标准）</li>
</ul>
</li>
</ul>
</li>
<li>数据类型<ul>
<li>数值<ul>
<li>INT，标准整数，4字节</li>
<li>FLOAT，单精度浮点数，4字节</li>
<li>DECIMAL，字符串形式的浮点数，Decimal(M,D),M为存储数，D为小数位</li>
<li>unsigned属性，标识为无符号数，就是数值不能增加符号，比如不能增加负号</li>
<li>zerofill属性，宽度不足以0填充</li>
</ul>
</li>
<li>字符串<ul>
<li>CHAR(M)，定长字符串，长度为M字节</li>
<li>VARCHAR(M)，可变字符串，节省存储空间</li>
</ul>
</li>
<li>日期<ul>
<li>DATETIME，YY-MM-DD hh:mm:ss</li>
<li>TIMESTAMP，YYYYMMDDHHMMSS</li>
</ul>
</li>
</ul>
</li>
<li><p>字段的约束及属性</p>
<ul>
<li>非空约束NOT NULL，字段不允许为空</li>
<li>默认约束DEFAULT，赋予某字段默认值</li>
<li>唯一约束UNIQUE KEY(UK)，设置字段的值是唯一的，允许为空，但只能有一个空值</li>
<li>主键约束PRIMARY KEY(PK)，设置该字段为表的主键，可唯一标识该表记录</li>
<li>外键约束FOREIGN KEY(FK)，用于在两表之间建立关系，需要指定引用主表的哪一个字段</li>
<li>自动增长AUTO_INCREMENT，设置该列为自增字段，默认每条自增1，通常用于设置主键</li>
</ul>
</li>
<li><p>修改表</p>
<pre><code>alter table 表名 rename to 新表名         #修改表名
alter table 表名 add 新字段 字段类型       #添加字段
alter table 表名 change 原字段名 新字段名 字段类型     #修改字段
alter table 表名 drop 字段名              #删除字段
</code></pre></li>
<li><p>添加主外键</p>
<pre><code>alter table 表名 add constraint 主键名 primary key 表名(主键字段)
#主键名可以随意，比如pk_studentNo

alert table 表名 add constraint 外键名 foreign key (外键字段) references 主表名(主键名)
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/28/初识MySQL/" data-id="cjfji2ugc003wagwvh86hyqj2" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL学习/">MySQL学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-BOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/BOM/" class="article-date">
  <time datetime="2018-02-27T09:35:34.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/BOM/">BOM</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>BOM</h5><p></p>
<hr>
<hr>
<p></p><h6>Window对象</h6><p></p>
<ul>
<li>window对象是BOM的根对象，其它对象其实都是window对象的属性，window对象的属性和方法都可以省略“window.”</li>
<li><p>window对象常用属性</p>
<pre><code>pageXOffset  设置或返回当前页面相对于窗口显示区左上角的x位置
pageYOffset  设置或返回当前页面相对于窗口显示区左上角的y位置
</code></pre></li>
<li><p>window对象常用方法</p>
<pre><code>alert() 显示带有一段消息和一个确认按钮的警告框
confirm()显示带有一段消息以及确认和取消按钮的对话框
prompt()显示可提示用户输入的对话框
close()关闭浏览器窗口
open()打开一个新的浏览器窗口或查找一个已命名的窗口
setInterval 按照指定的周期（以毫秒计）来调用函数或计算表达式
clearInterval取消由setInterval()设置的timeout

&lt;h1&gt;
    当前时间：&lt;span id=&quot;date&quot;&gt;&lt;/span&gt;
&lt;/h1&gt;
&lt;button onclick=&quot;fn1()&quot;&gt;开始时钟&lt;/button&gt;
&lt;button onclick=&quot;fn2()&quot;&gt;停止时钟&lt;/button&gt;
&lt;script&gt;
    var setid                                      //动态显示时间
    function fn1(){
        var span=document.getElementById(&quot;date&quot;)
        var date=new Date()
        span.innerHTML=date
        clearInterval(setid)
        setid=setInterval(function(){
            var date=new Date()
            span.innerHTML=date
        },1000)
    }
    function fn2(){
        clearInterval(setid)
    }
&lt;/script&gt;
</code></pre></li>
</ul>
<p></p><h6>Window常用子对象</h6><p></p>
<ul>
<li>navigator对象<ul>
<li>navigator对象包含浏览器的信息，常用于获取客户端浏览器和操作系统信息</li>
</ul>
</li>
<li>location对象<ul>
<li>location对象包含有关当前URL的信息，常用于获取和改变当前浏览的网址</li>
</ul>
</li>
<li>history对象<ul>
<li>history对象包含用户（在浏览器窗口中）访问过的URL的历史记录</li>
</ul>
</li>
<li>Screen对象<ul>
<li>Screen对象包含有关客户端显示屏幕的信息，用于获取屏幕的分辨率和色彩</li>
</ul>
</li>
<li><pre><code>&lt;script&gt;
    //navigator对象
    console.log(navigator)
    for(var i in navigator){
    console.log(i+&apos;:&apos;+navigator[i])
    }
    console.log(navigator.platform)//返回运行浏览器的系统操作平台

    //location对象，包含当前有关URL信息
    console.log(location.href)//返回完整的URL

    //history对象，访问URL历史记录
    //forward()   back()  go()
    console.log(history.length)  //返回浏览器历史列表中的URL数量

    //screen对象，包含客户端显示屏幕的信息
    console.log(screen.availHeight)//返回显示屏幕的高度（除Windows任务栏之外）
    console.log(screen.availWidth)//返回显示屏幕的宽度（除Windows任务栏之外）
&lt;/script&gt;
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/27/BOM/" data-id="cjfji2uap0001agwvehp6n0hp" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web前端/">Web前端</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-HTML DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/HTML DOM/" class="article-date">
  <time datetime="2018-02-27T09:35:14.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/HTML DOM/">HTML DOM</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>HTML DOM</h5><p></p>
<hr>
<hr>
<p></p><h6>标准DOM与HTML DOM</h6><p></p>
<ul>
<li>标准DOM提供了统一的操作接口<ul>
<li>createElement</li>
<li>appendChild</li>
<li>setAttribute</li>
<li>…</li>
</ul>
</li>
<li>HTML DOM提供了封装好的各种对象<ul>
<li>Image</li>
<li>Select</li>
<li>Option…</li>
</ul>
</li>
<li><p>标准DOM的实现方式</p>
<pre><code>var newNode = document.createElement(&apos;img&apos;);
</code></pre></li>
<li><p>HTML DOM的实现方式</p>
<pre><code>var newNode = new Image();
</code></pre></li>
<li>标准DOM操作适合于：<ul>
<li>操作节点，创建，删除，查找等</li>
</ul>
</li>
<li>HTML DOM操作适合于：<ul>
<li>操作属性，如读取或者修改属性的值</li>
</ul>
</li>
</ul>
<p></p><h6>常用HTML DOM对象</h6><p></p>
<ul>
<li><p>Image对象</p>
<ul>
<li>Image对象代表嵌入的图像</li>
<li>img标签每出现一次，一个Image对象就会被创建</li>
<li>也可以使用new Image()创建一个新的对象</li>
<li><p>常用属性：src,height,width</p>
<pre><code>var div=document.createElement(&apos;div&apos;)
document.body.appendChild(div)
var img=new Image()
img.src=&quot;001.jpg&quot;
div.appendChild(img)
</code></pre></li>
</ul>
</li>
<li><p>Table对象</p>
<pre><code>var arr=[
 [&apos;tom1&apos;,&apos;23&apos;,&apos;python&apos;],
 [&apos;tom2&apos;,&apos;23&apos;,&apos;python&apos;],
 [&apos;tom3&apos;,&apos;23&apos;,&apos;python&apos;],
 [&apos;tom4&apos;,&apos;23&apos;,&apos;python&apos;]
 ]
 var table=document.createElement(&apos;table&apos;)
 table.width=300
 table.border=1
 document.body.appendChild(table)
 for (var i in arr )
 {
     var tr=table.insertRow()
     for(var j in arr[i]){
        var td=tr.insertCell()
        td.innerHTML=arr[i][j]
     }
 }
 console.log(table.rows)//属性rows，返回表格的行
 table.insertRow(4)//在表格第五行创建一行
 table.deleteRow(4)//删除第五行

 console.log(table.rows[0].cells)//属性cells,获取所在行所有单元格
 console.log(table.rows[0].rowIndex)
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/27/HTML DOM/" data-id="cjfji2ucg000uagwvzpabjosv" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web前端/">Web前端</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-初识DOM与BOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/初识DOM与BOM/" class="article-date">
  <time datetime="2018-02-27T09:34:33.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/初识DOM与BOM/">初识DOM与BOM</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>DOM与BOM</h5><p></p>
<hr>
<hr>
<p></p><h6>DHTML</h6><p></p>
<ul>
<li>动态HTML,是一种将目前已有的网页技术、语言标准整合运用，制作出能在下载后仍然能实时变换页面元素效果的网页设计概念</li>
<li>DHTML的功能:动态改变页面元素；与用户进行交互<br>DHTML对象模型包括DOM和BOM</li>
<li>DOM：Document Object Model，文档对象模型，用来操作文档<ul>
<li>定义了访问和操作HTML文档的标准方法</li>
<li>通过对DOM树的操作，实现对HTML文档内容的操作</li>
</ul>
</li>
<li>BOM：Browser Object Model，浏览器对象模型，用来访问和操做浏览器窗口，使JavaScript有能力与浏览器“对话”<ul>
<li>通过使用BOM，可移动窗口，更改状态文本，执行其它与页面内容发生直接联系的操作</li>
</ul>
</li>
</ul>
<p></p><h6>DOM</h6><p></p>
<ul>
<li>W3C DOM标准被分为3个不同的部分：<ul>
<li>核心DOM 针对任何结构化文档的标准模型</li>
<li>XML DOM 针对XML文档的标准模型</li>
<li>HTML DOM针对HTML文档的标准模型（下面说这个）</li>
</ul>
</li>
<li>document对象<ul>
<li>文档中的所有节点组成了一个文档树，document对象是一颗文档树的根</li>
<li>浏览器内置的JS解释器会为载入的每个HTML文档创建一个对应的document对象</li>
<li>通过使用document对象，可以从脚本中对HTML页面中的所有元素进行访问</li>
</ul>
</li>
<li><p>DOM节点树</p>
<ul>
<li>文档中的元素、属性、文本、注释等都被看作一个节点</li>
<li><p>上下层节点：</p>
<pre><code>parentNode  获取父节点
childNodes  获取子节点集合
firstChild  获取第一个子节点
lastChild   获取最后一个子节点
</code></pre></li>
<li><p>平行层节点</p>
<pre><code>previousSibling  获取上一个兄弟节点
nextSibling      获取下一个兄弟节点
</code></pre></li>
<li>节点名称、类型、值<ul>
<li>nodeName、nodeType、nodeValue</li>
</ul>
</li>
</ul>
</li>
<li><p>元素节点属性</p>
<ul>
<li>innerHTML 读取或设置元素节点中的HTML内容</li>
<li>textContent 用于读取或设置元素节点中的文本内容</li>
<li><p>attributes 返回节点的属性集合，即一个类数组对象</p>
<ul>
<li><p>读取属性</p>
<pre><code>（1）element.attributes[下标].value
（2）element.attributes[&apos;属性名&apos;].value
（3）element.getAttributeNode(&apos;属性名&apos;).value
（4）element.getAttribute(&apos;属性名&apos;)
</code></pre></li>
<li><p>设置属性</p>
<pre><code>（1）element.setAttribute(name,value);
（2）element.setAttributeNode(attrNode)
</code></pre></li>
<li><p>移除属性</p>
<pre><code>（1）element.removeAttribute(&apos;属性名&apos;);
（2）element.removeAttributeNode(attrNode)
</code></pre></li>
<li><p>判断属性</p>
<pre><code>element.hasAttribute(&apos;属性名&apos;);//true或false
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>动态创建DIV</p>
<pre><code>&lt;body&gt;
    &lt;button onclick=&quot;createDiv()&quot;&gt;创建DIV&lt;/button&gt;
    &lt;h1 style=&quot;clear:both&quot;&gt;&lt;/h1&gt;
    &lt;script&gt;
        function createDiv(){
            var div=document.createElement(&apos;div&apos;)
            div.setAttribute(&apos;style&apos;,&apos;width:100px;height:100px;background:&apos;+roundColor()+&apos;;margin:20px;float:left&apos;)
            document.body.appendChild(div)
            div.onclick=removeDiv
        }
        function roundColor(){
            var str=&apos;1234657890abcdef;
            var s=&apos;#&apos;;
            for (var i=0; i&lt;6; i++)
            {
                var n=parseInt(Math.random()*str.length)
                s+=str.charAt(n)
            }
            return s;
        }
        function removeDiv(){
            document.body.removeChild(this);
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/27/初识DOM与BOM/" data-id="cjfji2ugc003uagwvklcy45rv" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web前端/">Web前端</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-匿名函数、封装继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/匿名函数、封装继承/" class="article-date">
  <time datetime="2018-02-27T04:21:32.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/匿名函数、封装继承/">匿名函数、封装继承</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>匿名函数、封装继承</h5><p></p>
<hr>
<hr>
<p></p><h6>匿名函数</h6><p></p>
<ul>
<li><p>JavaScript中创建函数的三种方式</p>
<pre><code>//使用function关键字声明命名函数
function functionName{
    functionBody;
}
//使用直接量方式命名函数
var functionName = function(){
    functionBody;
}
//使用Function对象构造方法创建函数
var functionName = new Function(arg1,arg2,functionBody)
</code></pre></li>
<li><p>匿名函数，就是定义时未直接指定名称的函数，仅在调用时，才临时创建函数对象和作用域链对象，调用完，立刻释放；所以，匿名函数比非匿名函数更节省内存空间</p>
<pre><code>function(num1,num2){
    console.log(num1+num2);
}

var fn1=function(){
    console.log(&quot;sad&quot;)
}();                //隐式匿名函数；匿名函数只能调用一次，调用完立即释放
fn1()                //sad
fn1()                //fn1 is not a function

function a(fn){
    var num=fn()
    console.log(num)
}
a(function(){          //回调函数，将一个函数作为另一个函数的参数
    return 10+3
})                  //13
</code></pre></li>
</ul>
<p></p><h6>闭包</h6><p></p>
<ul>
<li><p>函数套函数，该函数能使用函数外定义的变量</p>
<pre><code>function a(){
    function b(){
        console.log(1)  //闭包；函数套函数；就是一种访问局部变量的特殊方式
    }
    b()
}
a()
</code></pre></li>
<li><p>闭包的主要作用是：</p>
<ul>
<li>1.提供可共享的局部变量</li>
<li>2.保护共享的局部变量。提供专门的读写变量的函数</li>
<li>3.避免全局污染</li>
</ul>
</li>
</ul>
<p></p><h6>封装继承</h6><p></p>
<ul>
<li>封装：把相关的信息（无论数据或方法）存储在对象中<br>继承：从其它对象获得属性和方法<br>多态：能以多种不同的形式运行函数或方法<br>原型：在JavaScript中，函数本身也是一个包含了方法和属性的对象，每个函数都有一个prototype属性，该属性引用的是原型对象；原型对象是保存共享属性值和共享方法的对象</li>
<li>JavaScript中主要通过原型实现继承，通过原型实现继承主要有以下两中方式：<ul>
<li>1.修改构造函数的原型，为该构造函数创建的对象指定统一的父级对象<br>语法：构造函数.prototype = 父级对象；</li>
<li>2.单独修改一个对象的原型，而不影响其它对象的原型<br>语法：Object.setPrototypeOf(子对象,父级对象)</li>
</ul>
</li>
<li><p>说明</p>
<pre><code>&lt;script&gt;
    function emp(ename,age){                //工厂函数
        this.ename=ename;                   //谁调用this，this就指向谁;运用在函数中,this为当前对象
        this.age=age;
        console.log(this);
    }
    //为原型添加属性，子对象自动继承原型（父对象）所有的属性和方法
    emp.prototype.jineng=&quot;我们都会HTML&quot;      //prototype是构造函数的方法，扩展共享属性值
    var obj1=new emp(&apos;Tom&apos;,&apos;30&apos;)            //实例化对象
    obj1.job=function(){                    //自有属性/方法
        console.log(&apos;JAVA&apos;)
    }
    obj1.job()                              //JAVA
    var obj2=new emp(&apos;Array&apos;,&apos;28&apos;)
    obj2.work=function(){
        console.log(&apos;Python&apos;)
    }
    Object.setPrototypeOf(obj2,obj1)        //修改单个对象的原型,前子后父
    obj2.job()                              //JAVA
    obj2.work()                             //Python
    console.log(obj1.jineng)                //我们都会HTML
    console.log(obj2.jineng)                //我们都会HTML

    function a(){
        this.ename=&quot;Tom&quot;
    }
    function b(){
        this.age=&quot;29&quot;
    }
    b.prototype=new a()            //修改原型父对象,只有函数名能调用prototype
    var obj=new b()
    console.log(obj.age)        //29
    console.log(obj.ename)      //Tom

    var heihei={age:25}            //直接量创建对象
    var obj={name:123};
    Object.setPrototypeOf(obj,heihei)
    //console.log(obj)             //打印出来是undefined,其原型是Object
    console.log(Object.getPrototypeOf(obj))     //获取原型
    console.log(heihei.isPrototypeOf(obj))      //isPrototypeOf()方法用于判定一个prototype对象是否存在于另一个对象的原型链中
&lt;/script&gt;
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/27/匿名函数、封装继承/" data-id="cjfji2ugc003yagwvsow1kijb" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web前端/">Web前端</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-模块、包、枚举" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/26/模块、包、枚举/" class="article-date">
  <time datetime="2018-02-26T10:56:37.000Z" itemprop="datePublished">2018-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/26/模块、包、枚举/">模块、包、枚举</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>模块、包、枚举</h5><p></p>
<hr>
<hr>
<p></p><h6>模块</h6><p></p>
<ul>
<li>Python 模块(Module)，是一个 Python文件，以.py 结尾，包含了Python对象定义和Python语句</li>
<li><p>1.使用 python 标准库中模块</p>
<pre><code>import datetime                 #引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法
print(datetime.datetime.now())  #显示当前时间
print(datetime.datetime.now()+datetime.timedelta(3))  #显示当前时间+3天
</code></pre></li>
<li><p>2.import语句,想使用 Python 源文件，只需在另一个源文件里执行 import 语句</p>
<pre><code>先定义一个名为test1.py的模块
#!/usr/bin/env python      #这行注释可以让这个文件直接在Unix/Linux/Mac上运行
#__author__:LiuYongqian
&apos; a test module &apos;          #表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释
def print_mes(x):
    print(&apos;Hello:&apos;,x)
def add(x,y):
    print(x+y)

在test2.py中引入test1模块
#!/usr/bin/env python
#__author__:LiuYongqian
import test1             #导入模块，下面可以调用模块里的函数了
test1.print_mes(&apos;2018&apos;)  #result: Hello: 2018
test1.add(3,6)           #result:9
</code></pre></li>
<li><p>3.from … import语句，from语句让你从模块中导入一个指定的部分到当前命名空间</p>
<pre><code>from test1 import print_mes
print_mes(&apos;2018&apos;)        #result:Hello: 2018
</code></pre></li>
</ul>
<p></p><h6>包</h6><p></p>
<ul>
<li>目录只有包含一个叫做__init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块</li>
</ul>
<p></p><h6>枚举</h6><p></p>
<ul>
<li>枚举类型可以看作是一种标签或是一系列常量的集合，通常用于表示某些特定的有限集合，例如星期、月份、状态等</li>
<li><p>为何要用枚举</p>
<pre><code>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如星期：
MON,TUE,WED,THI,FRI,STA,SUN=1,2,3,4,5,6,7
这样定义的好处是简单，缺点是类型是整型，仍然是变量，更好的办法是为这样的枚举类型定义一个class类型，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能：
from enum import Enum
Week=Enum(&apos;Week&apos;,(&apos;Mon&apos;,&apos;Tue&apos;,&apos;Wed&apos;,&apos;Thi&apos;,&apos;Fri&apos;,&apos;Sta&apos;,&apos;Sun&apos;))
这样我们就获得了Week类型的枚举类，可以直接使用Week.Mon来引用一个常量，或者枚举它的所有成员：
print(Week[&apos;Wed&apos;])       #通过成员的名称来获取成员   #result:Week.Wed
print(Week(3))           #通过成员的值来获取成员     #result:Week.Wed
mem=Week.Wed             #通过成员，来获取它的名称和值
print(mem.name)          #result:Wed
print(mem.value)         #result:3
for name,member in Week.__members__.items():  #值重复的成员也遍历出来，要用枚举的一个特殊属性__members__
    print(name,&apos;=&gt;&apos;,member,&apos;-&apos;,member.value)  #value属性是自动赋给成员的int常量，默认从1开始计数
#result:
Mon =&gt; Week.Mon - 1         
......
Sun =&gt; Week.Sun - 7
</code></pre></li>
<li><p>如果需要更加精确的控制枚举类型，可以从Enum派生出自定义类</p>
<pre><code>from enum import Enum,unique
@unique              #该装饰器可以帮助我们检查保证没有重复值。
class Week(Enum):    #用于定义枚举的class和定义类的class是有区别的
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
    sun = 7
print(Week[&apos;Thu&apos;])           #result:Week.Thu
print(Week(4))               #result:Week.Thu
for week in Week:
    print(week)
#result:
Week.Mon
......
Week.sun
</code></pre></li>
<li><p>小练习：把Student的gender属性改造为枚举类型，可以避免使用字符串</p>
<pre><code>from enum import Enum,unique
class Gender(Enum):
    Female=0
    Male=1
class Student():
    def __init__(self,name,gender):
        self.name=name
        self.gender=gender
mm=Student(&apos;LiuYongqian&apos;,Gender.Male)
if mm.gender==Gender.Male:
    print(&apos;信息正确!&apos;)
else:
    print(&apos;信息错误！&apos;)
#result: 信息正确!
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/26/模块、包、枚举/" data-id="cjfji2ui3004uagwvqglo9o24" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-闭包、装饰、冒泡" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/24/闭包、装饰、冒泡/" class="article-date">
  <time datetime="2018-02-24T07:19:11.000Z" itemprop="datePublished">2018-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/24/闭包、装饰、冒泡/">闭包、装饰、冒泡</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>闭包、装饰、冒泡</h5><p></p>
<hr>
<hr>
<p></p><h6>冒泡</h6><p></p>
<ul>
<li><p>执行机制：两两相比，外侧循环n-1,控制比较多少轮;内侧循环n-1-i，控制每轮比较多少次</p>
<pre><code>m=[3,4,5,1,2,6]            #升序
for i in range(len(m)-1):
    for j in range(len(m)-1-i):
        if m[j]&gt;m[j+1]:
            m[j],m[j+1]=m[j+1],m[j]
            &apos;&apos;&apos;
            n=m[j]
            m[j]=m[j+1]
            m[j+1]=n
            &apos;&apos;&apos;
&apos;&apos;&apos;
for i in range(len(m)):     #插入数据不改变排列顺序
    if m[i]&gt;3:
        m.insert(i,7)
        break
&apos;&apos;&apos;        
print(m)                    #result:[1, 2, 3, 4, 5, 6]
</code></pre></li>
</ul>
<p></p><h6>闭包</h6><p></p>
<ul>
<li>如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包（closure）。一个闭包就是你调用了一个函数A，这个函数A返回了一个函数B给你。这个返回的函数B就叫做闭包</li>
<li><p>构成闭包的三个条件：</p>
<ul>
<li>1.必须有一个内嵌函数</li>
<li>2.内嵌函数必须引用一个定义在闭合范围外的变量，内部函数引用外部变量但非全局变量</li>
<li><p>3.外部函数必须返回内嵌函数</p>
<pre><code>def A():
    num = 10
    def B():
        nonlocal num        # nonlocal 声明变量位置是闭包
        num = num + 5
        return 39
    return B                #函数名后边加小括号的是立即调用，不带小括号的是引用，还没有执行
A()
print(A)                    #result:&lt;function A at 0x000001D42CA47F28&gt;
print(A().__name__)         #result:B
print(A()())                #result:39

def funcx(x):
    def funcy(y):
        return x*y
    return funcy
m=funcx(3)
n1=m(9)
n2=m(6)
print(n1)                    #result:27
print(n2)                    #result:18

def test(a,b,fun):
    return fun(a,b)
func=input(&apos;请输入一个函数：&apos;) #lambda a,b:a+b
m=test(3,9,eval(func))       #eval函数将字符串当成有效python表达式来求值，并返回计算结果
print(m)                     #result:12
</code></pre></li>
</ul>
</li>
</ul>
<p></p><h6>装饰器</h6><p></p>
<ul>
<li><p>装饰器函数传入被装饰函数，返回内层函数，就是闭包函数，它起到装饰给定函数的作用</p>
<pre><code>def outter(fun):             #成为装饰器必须有一个参数
    def inner():
        print(&apos;I Like You!&apos;)
        fun()                #有这个，被装饰的函数才会执行
    return inner

@outter
def index():
    print(&apos;I Hate You!&apos;)
index()                      #result:I Like You!     I Hate You!

def coat(fun):
    print(&apos;穿上衣服&apos;)
    return fun
def bag(fun):
    print(&apos;带着书包&apos;)
    return fun
def bybus(fun):
    print(&apos;坐着校车&apos;)
    return fun
@bybus
@bag                          #靠近函数的装饰器最先执行，从下往上执行
@coat                         #student函数和print打包作为参数传给装饰器bag，以此类推
def student():
    print(&apos;学生去上课！&apos;)
student()                     #result:穿上衣服 带着书包 坐着校车 学生去上课！

#火锅店
def yangrou(fun):
    sum=30+fun()
    print(&apos;肥羊肉&apos;)
    return sum
def zhangliao(fun):
    print(&apos;芝麻酱&apos;)
    return 5+fun

@zhangliao
@yangrou
def guodi():
    print(&apos;微辣底料&apos;)
    return 12
print(guodi)

#火锅店变形
import types
def yangrou(fun):
    sum=0
    if type(fun)==types.FunctionType:
        sum=30+fun()
    else:
        sum=30+fun
    print(&apos;肥羊肉&apos;)
    return sum
def zhangliao(fun):
    sum = 0
    if type(fun) == types.FunctionType:
        sum =5 + fun()
    else:
        sum =5 + fun
    print(&apos;芝麻酱&apos;)
    return sum
@zhangliao
@yangrou
def guodi():
    print(&apos;微辣底料&apos;)
    return 12
print(guodi)

#火锅店变形
def yangrou(fun):
    def caidan1():
        print(&apos;肥羊肉&apos;)
        return 30+fun()
    return caidan1
def zhangliao(fun):
    def caidan3():
        print(&apos;芝麻酱&apos;)
        return 5+fun()
    return caidan3
@zhangliao
@yangrou
def guodi():
    print(&apos;微辣底料&apos;)
    return 12
print(guodi())
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/24/闭包、装饰、冒泡/" data-id="cjfji2uij005gagwv7fc21tbn" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Js对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/23/Js对象/" class="article-date">
  <time datetime="2018-02-23T12:38:06.000Z" itemprop="datePublished">2018-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/23/Js对象/">Js对象</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>JS对象</h5><p></p>
<hr>
<hr>
<p></p><h6>内置对象</h6><p></p>
<ul>
<li>内置对象就是ECMAScript标准中已经定义好的，由浏览器厂商已经实现的标准对象！内置对象中封装了专门的数据和操作数据常用的API</li>
<li>JavaScript中内置对象列表：String、Boolean、Number、Array、Date、RegExp、Math、Error、Function、Object、Global</li>
</ul>
<p></p><h6>String对象</h6><p></p>
<ul>
<li><p>String对象用于处理文本字符串,JavaScript中字符串的内容都是不可变的</p>
<pre><code>创建原始类型字符串变量：
var ename = &apos;Tom&apos;;
创建引用类型字符串对象：
var stuName = new String(&apos;Hello World&apos;)
</code></pre></li>
<li><p>String对象的所用方法，返回的都是一个全新的对象，而不是修改原始字符串内容</p>
<pre><code>toLowerCase()方法返回字符串的小写;
toUpperCase()方法返回字符串的大写;
charAt()方法用于获取指定下标的字符;
charCodeAt()方法用于获取指定下标的字符的Unicode码;
indexOf()返回第一次出现指定子串的下标;
lastIndexOf()返回最后一次出现指定子串的下标;
slice(start,[end])返回从start到end-1范围内的子串;
substring(start,[end])返回从start到end-1范围内的子串;
split()使用指定分隔符对字符串进行拆分，返回数组
concat()用于拼接两个或多个字符串
replace()方法用于在字符串中用一些字符替换特定的字符，或替换一个与正则表达式匹配的子串
match()方法可在字符串内检索指定的值，或找到一个或多个与正则表达式匹配的子串
search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。
返回第一个与regexp相匹配的子串的起始位置；如果没有找到任何匹配的子串，则返回-1

var str=&quot;老鹰来了&quot;
var s=&quot;&quot;                          //编码
function fn1(){
    for(var i=0;i&lt;str.length;i++){
            s+=str.charCodeAt(i);
    }
    console.log(s)
}
fn1()
function fn2(){                      //解码
    for(var i=0;i&lt;s.length;i+=5){
        var n=s.slice(i,i+5);
        var num=Number(n);
        var s1=String.fromCharCode(num);
        console.log(s1)
    }
}
fn2()
</code></pre></li>
</ul>
<p></p><h6>Math对象</h6><p></p>
<ul>
<li>Math对象是ECMAScript提供的一个全局对象，它主要封装了一些常用的数学函数和常数<br>Math对象没有构造函数，无法创建它的实例；调用其属性和方法时，直接使用Math对象名即可</li>
<li><p>Math对象具有如下成员属性：</p>
<pre><code>E  返回算术常量e，即自然对数的底数（约等于2.718）
PI 返回圆周率（约等于3.14159）
</code></pre></li>
<li><p>Math对象具有如下方法：</p>
<pre><code>abs(x)   返回数的绝对值
ceil(x)  对数进行上舍入
floor(x) 对数进行下舍入
max(x,y) 返回x和y中的最高值
min(x,y) 返回x和y中的最低值
pow(x,y) 返回x的y次幂
round(x) 把数四舍五入为最接近的整数
sqrt(x)  返回数的平方根
</code></pre></li>
<li><p>随机数</p>
<pre><code>console.log(Math.random())//0-1之间的随机数，不包括1
console.log(Math.random()*100)//0-99随机整数
console.log(Math.random()*90+10)//10-99之间的随机整数
</code></pre></li>
</ul>
<p></p><h6>Date对象</h6><p></p>
<ul>
<li><p>Date对象用于对时期和时间进行存储和计算</p>
<pre><code>var date=new Date()
date.getDate()            //日期
date.getMonth()           //月份0-11
date.getMinutes()        //分钟
date.getSeconds()        //秒
date.getMilliseconds()    //毫秒
date.getHours()            //小时

date.toString()                //返回Date对象的字符串形式
date.toLocaleString()        //基于本地时间格式，返回Date对象的字符串形式
date.toLocaleTimeString()    //基于本地时间格式返回Date对象“时间”部分（时分秒）的字符串形式
date.toGMTString()            //基于GMT时间格式，返回Date对象的字符串形式
date.toUTCString()            //基于UTC时间格式，返回Date对象的字符串形式
</code></pre></li>
</ul>
<p></p><h6>Number对象</h6><p></p>
<ul>
<li><p>Number对象表示数值数据和数字常数，主要用于对数字进行指定格式的输出</p>
<pre><code>//构造新的Number对象----引用类型的变量
var num1 = new Number(5);         //[Number:5]
var num2 = new Number(“5”)        //[Number:5]
var num3 = new Number(“hello”)    //[Number:NaN]
//将数据转换为Number数据类型-----值类型的变量
var num4 = Number(“123”);         //123
</code></pre></li>
</ul>
<p></p><h6>Error对象</h6><p></p>
<ul>
<li><p>六种错误对象：</p>
<pre><code>1、Error：  广泛意义上的错误
2、SyntaxError： 语法错误      var x = 10; x+++;
3、ReferenceError:  引用错误     var userName = &apos;tom&apos;;  console.log(uName);
4、TypeError:  类型错误     console.abc();
5、EvalError:  eval()函数执行错误    
6、RangeError：范围错误     var n = 123.456;    console.log( n.toFixed(20) );
7、URIError:  URI解析错误
</code></pre></li>
<li><p>try/catch<br><br>ECMAScript中使用try…catch…finally…结构来执行异常处理功能，捕捉由系统生成或程序创建并抛出的Error对象，对错误情形加以处理。它的基本语法如下：</p>
<pre><code>try{
     //此处是主业务功能代码
     //主业务功能代码中肯能产生并抛出错误
}catch(error){
     //此处是负责错误处理的代码
}[finally{
     //此处是出口语句，不论错误发生与否都要执行
}]
</code></pre></li>
</ul>
<p></p><h6>Function对象</h6><p></p>
<ul>
<li><p>在JavaScript中，函数也是以对象的形式存在的。每个函数都是一个Function对象实例</p>
<pre><code>function add(){
}
console.log(typeof add);      //function 
//函数名，本质也是一个变量名，是指向某个Function对象的引用
</code></pre></li>
</ul>
<p></p><h6>arguments对象</h6><p></p>
<ul>
<li>每个函数对象都有一个arguments属性；此属性只能在函数执行体内使用<br>arguments属性中保存着当前函数接受到的所有实际参数，故可以使用arguments属性处理可变数量的参数</li>
<li><p>arguments对象具有如下属性：</p>
<pre><code>length：返回实际传入的参数的个数
callee：返回当前函数的引用
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/23/Js对象/" data-id="cjfji2ucv0015agwvwx0dbiv0" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web前端/">Web前端</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django学习/">Django学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git学习/">Git学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP协议/">HTTP协议</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux学习/">Linux学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB数据库/">MongoDB数据库</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL学习/">MySQL学习</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python学习/">Python学习</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis数据库/">Redis数据库</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web前端/">Web前端</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全测试/">安全测试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包工具/">抓包工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫学习/">爬虫学习</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化测试/">自动化测试</a><span class="tag-list-count">5</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django学习/" style="font-size: 12.86px;">Django学习</a> <a href="/tags/Git学习/" style="font-size: 12.86px;">Git学习</a> <a href="/tags/HTTP协议/" style="font-size: 10px;">HTTP协议</a> <a href="/tags/Linux学习/" style="font-size: 12.86px;">Linux学习</a> <a href="/tags/MongoDB数据库/" style="font-size: 11.43px;">MongoDB数据库</a> <a href="/tags/MySQL学习/" style="font-size: 14.29px;">MySQL学习</a> <a href="/tags/Python学习/" style="font-size: 20px;">Python学习</a> <a href="/tags/Redis数据库/" style="font-size: 15.71px;">Redis数据库</a> <a href="/tags/Web前端/" style="font-size: 18.57px;">Web前端</a> <a href="/tags/安全测试/" style="font-size: 11.43px;">安全测试</a> <a href="/tags/性能测试/" style="font-size: 10px;">性能测试</a> <a href="/tags/抓包工具/" style="font-size: 10px;">抓包工具</a> <a href="/tags/爬虫学习/" style="font-size: 17.14px;">爬虫学习</a> <a href="/tags/自动化测试/" style="font-size: 12.86px;">自动化测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/03/富文本、分页/">富文本、分页</a>
          </li>
        
          <li>
            <a href="/2018/04/02/scrapy选择器css、xpath/">scrapy选择器css、xpath</a>
          </li>
        
          <li>
            <a href="/2018/04/02/scrapy命令行详解/">scrapy命令行详解</a>
          </li>
        
          <li>
            <a href="/2018/04/01/发布及文件上传/">发布及文件上传</a>
          </li>
        
          <li>
            <a href="/2018/04/01/HTTP报文/">HTTP报文</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
       Email:<a>liuyongqian51@163.com</a><br />
          QQ:<a>272501447</a><br />
	  Github:<a></a>
    </div>
  </div>

  
  

</aside>


        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 刘永前<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>

</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>