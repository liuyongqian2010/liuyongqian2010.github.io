<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>LiuYongQian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="永远相信美好的事情将要发生！">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongQian">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="LiuYongQian">
<meta property="og:description" content="永远相信美好的事情将要发生！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongQian">
<meta name="twitter:description" content="永远相信美好的事情将要发生！">
  
    <link rel="alternate" href="/atom.xml" title="LiuYongQian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongQian</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">永远相信美好的事情将要发生！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SQL注入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/SQL注入/" class="article-date">
  <time datetime="2018-03-10T14:12:52.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/SQL注入/">SQL注入</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>SQL注入</h5><p></p>
<hr>
<hr>
<p></p><h6>概念</h6><p></p>
<ul>
<li>攻击者之所以可以利用自己输入的数据来达到攻击网站的目的，原因就在于SQL语言作为一种解释型语言，它的数据其实是由程序员编写的代码和用户提交的数据共同组成的。正是这个原因，攻击者可以构造对自己有利的数据，利用网站的一些SQL漏洞来达到恶意的目的</li>
<li>SQL注入，就是指攻击者将恶意的字符串或者语句等信息作为参数输入，服务器在验证这个字段的时候，读取攻击者输入的数据，将其作为正常的值参与SQL语句的查询，试想，如果攻击者输入了一个字符串，在SQL语句执行之后，可以导致删除表等操作，对于一个应用来说，影响是很大的</li>
<li>通过网页的输入项来注入SQL查询或命令是一种技巧。许多网页会从用户那里获取参数，并构建SQL查询来访问数据库。以用户登录为例，页面收集用户名和密码然后构建SQL去查询数据库，来校验用户名和密码的有效性。</li>
</ul>
<p></p><h6>简单实例</h6><p></p>
<ul>
<li>某网站的登录功能，用户登录页面需要填写用户名和密码，假设如果其中一个用户名和密码是admin和123456，当用户在相应的表单中输入正确的用户名和密码之后，此应用的相应函数执行一定的验证（验证用户名和密码是否匹配），服务器执行SQL语句（表名是user）：<code>select * from user where username=’username’ and pwd=’password’</code>，逻辑是如果这个查询语句返回结果不为0，则认为是验证通过，即可以登录成功的用户</li>
<li>如果某用户输入admin和123456，即执行语句：select * from user where username=’admin’ and pwd=’123456’,执行结果不为0，所以用户登录成功</li>
<li>如果一个用户输入test’ or 1=’1和111111，即执行语句：select * from user where username=’test’ or 1=’1’ and pwd=’111111’，因为此查询语句中1=’1’的结果为1，or 1=’1’使查询条件始终返回1，因此此语句的查询结果不为0，这样，此用户没有使用正确的用户名和密码也可以登录成功，这就是SQL注入的一个简单实例</li>
</ul>
<p></p><h6>SQL注入一般会出现在哪些地方</h6><p></p>
<ul>
<li>含有输入数据表单的页面（登录界面、查询界面、反馈界面等），即使是hidden的表单也有可能存在这个问题</li>
<li>含有用户信息、ID等的URL（类似于<code>http://XXX/index.asp?ID=155</code>），可以操作ID后的参数数据</li>
</ul>
<p></p><h6>SQL注入的防范措施</h6><p></p>
<ul>
<li>从开发者的角度来说，防范措施如下<ul>
<li>转义敏感字符及字符串<br>SQL的敏感字符包括： “exec”, “xp<em>”, “sp</em>”, “declare”, “cmd”, “Union”, “+”, “//”,              ”..”, “;”, “’”, “–”, “%”, “0x”, “&gt;&lt;=!-*/()|” ,和空格</li>
<li>屏蔽出错信息：阻止攻击者知道攻击的结果</li>
<li>在服务端正式处理之前提交数据的合法性(合法性检查主要包括三 项:数据类型,数据长度,敏感字符的校验)进行检查等。最根本的解决手段,在确认客 户端的输入合法之前,服务端拒绝进行关键性的处理操作</li>
</ul>
</li>
<li>从测试人员的角度来说，防范措施是<ul>
<li>在程序开发前(即需求阶段),我们就应该有意识的将安全性检查应用到需求测试中,例如对一个表单需求进行检查时,我们一般检验以下几项安全性问题:需求中应说明表单中某一field的类型,长度,以及取值范围(主要作用就是禁止输入敏感字符)；需求中应说明如果超出表单规定的类型,长度,以及取值范围的,应用程序应给出不包含任何代码或数据库信息的错误提示等</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/SQL注入/" data-id="cjyzyo0rw003h3cwvum7f3jhh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全测试/">安全测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-基本安全测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/基本安全测试/" class="article-date">
  <time datetime="2018-03-10T08:10:50.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/基本安全测试/">基本安全测试</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>基本安全测试</h5><p></p>
<hr>
<hr>
<p></p><h6>用户权限测试</h6><p></p>
<ul>
<li>用户权限控制<ul>
<li>用户权限控制主要是对一些有权限控制的功能进行验证</li>
<li>用户A才能进行的操作，B是否能够进行操作</li>
<li>只能有A条件的用户才能查看的页面，是否B能够查看（可直接敲URL访问）</li>
</ul>
</li>
<li>页面权限控制<ul>
<li>必须有登陆权限的页面，是否能够在不登陆情况下进行访问</li>
<li>必须经过A——B——C的页面，是否能够直接由A——C？</li>
</ul>
</li>
</ul>
<p></p><h6>URL安全测试</h6><p></p>
<ul>
<li>适用范围： URL中含有参数，也就是通过GET方式传递的HTTP请求</li>
<li>什么叫GET方式<ul>
<li>GET方式在客户端通过URL提交数据，数据在URL中可以看到</li>
<li>POST方式，数据放置在HTML HEADER内提交，数据在URL中看不到</li>
<li>GET只能传输比较少的数据，安全性较低，POST传输数据较多，安全性也比GET高</li>
</ul>
</li>
<li><p>测试关注点</p>
<ul>
<li>URL 参数检查<ul>
<li>对URL中参数信息检查是否正确，如：URL中的订单号、金额允许显示出来的话，需要验证其是否正确</li>
<li>对于一些重要的参数信息，不应该在URL中显示出来，如：用户登陆时登录名、密码是否被显示出来了</li>
</ul>
</li>
<li>URL参数值篡改<ul>
<li>修改URL中的数据，看程序是否能识别，对于URL中包含金额参数的，修改金额看是否能够提交成功（可能导致用户把2元金额改成1元金额能提交），还有修改订单号等重要信息看是否会报错</li>
</ul>
</li>
<li><p>URL中参数修改进行XSS注入</p>
<ul>
<li><p>XSS的全称是Cross Site Script（跨站点脚本），XSS的原理很简单，即进行脚本注入，URL执行时即把此脚本进行了执行，一般都是JavaScript脚本</p>
<pre><code>如“http://www.cnblogs.com/javame/index.asp?IDClass=2&amp;ClassName=abc”

改成“http://www.cnblogs.com/javame/index.asp?IDClass=2&amp;ClassName=abc&lt;script&gt;alert(&quot;hello&quot;);&lt;/script&gt;”

看看有没弹出对话框显示hello，有的话就有跨站漏洞
</code></pre></li>
</ul>
</li>
<li><p>URL参数中进行SQL注入</p>
<ul>
<li>SQL注入全称是SQL Injection ，当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击，如查询、插入数据时</li>
<li>测试方法： URL中写入SQL注入语句，看是否被执行<br>如：www.cnblogs.com/javame这个网站中，选择登陆设置用户名为 admin ‘ or ‘1’=’1 密码为任意数字 ，点击登录就可以登陆。一般情况下要进行SQL注入攻击，需要对数据库类型、表名、判断逻辑、查询语句等比较清楚才能够写出有效的SQL注入语句</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><h6>表单提交安全测试</h6><p></p>
<ul>
<li>适用范围：有表单提交的地方、有HTTP请求的地方</li>
<li>测试关注点<ul>
<li>表单中注入XSS脚本<ul>
<li>即在表单填写框中直接注入JS脚本如在表单中输入XSS脚本，程序是不应该让脚本执行的</li>
</ul>
</li>
<li>表单中注入SQL 脚本<ul>
<li>与URL中参数进行XSS注入类似，就是在表单中写入SQL注入脚本提交看是否会有问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><h6>Session测试</h6><p></p>
<ul>
<li>Session是客户端与服务器端建立的会话，总是放在服务器上的，服务器会为每次会话建立一个sessionId，每个客户会跟一个sessionID对应，并不是关闭浏览器就结束了本次会话，通常是用户执行“退出”操作或者会话超时时才会结束</li>
<li>测试关注点<ul>
<li>Session互窜<ul>
<li>Session互窜即用户A的操作被用户B执行了</li>
<li>验证Session互窜，其原理还是基于权限控制，如某笔订单只能是A进行操作，或者只能是A才能看到的页面，但是B的session窜进来却能够获得A的订单详情等</li>
<li>Session互窜方法<ul>
<li>多TAB浏览器，在两个TAB页中都保留的是用户A的session记录，然后在其中一个TAB页执行退出操作，登陆用户B，此时两个TAB页都是B的session，然后在另一个A的页面执行操作，查看是否能成功。预期结果：有权限控制的操作，B不能执行A页面的操作，应该报错，没有权限控制的操作，B执行了A页面操作后，数据记录是B的而不是A的</li>
</ul>
</li>
</ul>
</li>
<li>Session超时<ul>
<li>基于Session原理，需要验证系统session是否有超时机制，还需要验证session超时后功能是否还能继续走下去</li>
<li>测试方法：<ul>
<li>打开一个页面，等着10分钟session超时时间到了，然后对页面进行操作，查看效果</li>
<li>多TAB浏览器，在两个TAB页中都保留的是用户A的session记录，然后在其中一个TAB页执行退出操作，马上在另外一个页面进行要验证的操作，查看是能继续到下一步还是到登录页面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/基本安全测试/" data-id="cjyzyo0wz006g3cwvayiz60ld" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全测试/">安全测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-事务视图索引备份" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/09/事务视图索引备份/" class="article-date">
  <time datetime="2018-03-09T10:10:58.000Z" itemprop="datePublished">2018-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/09/事务视图索引备份/">事务视图索引备份</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>事务视图索引备份</h5><p></p>
<hr>
<hr>
<p></p><h6>事务</h6><p></p>
<ul>
<li><p>事务是一个不可分割的工作逻辑单元 </p>
<pre><code>begin;   #开始事务（指定事务从此处开始，后续的SQL语句都是一个整体）
update bank set currentMoney=currentMoney-1000 
where customerName=&apos;张三&apos;;
update bank set currentMoney=currentMoney+1000 
where customerName=&apos;李四&apos;;
commit;  #提交事务，事务结束

begin;
update bank set currentMoney=currentMoney-1000 
where customerName=&apos;张三&apos;;
update bank set currentMoney=currentMoney+1000 
where customerName=&apos;李四&apos;;
rollback;  #回滚事务，数据恢复到原始状态

#转账过程就是一个整体它需要两条UPDATE语句来完成，
这两条语句是一个整体如果其中任一条出现错误，
则整个转账业务也应取消，
两个账户中的余额应恢复到原来的数据，
从而确保转账前和转账后的余额不变，即都是1001元
</code></pre></li>
<li><p>事务必须具备以下四个属性，简称ACID 属性</p>
<ul>
<li>原子性（Atomicity）<ul>
<li>事务是一个完整的操作，事务的各步操作是不可分的(原子的)，要么都执行，要么都不执行</li>
</ul>
</li>
<li>一致性（Consistency）<ul>
<li>当事务完成时，数据必须处于一致状态</li>
</ul>
</li>
<li>隔离性（Isolation）<ul>
<li>并发事务之间彼此隔离、独立，它不应以任何方式依赖于或影响其他事务</li>
</ul>
</li>
<li>持久性（Durability）<ul>
<li>事务完成后,它对数据库的修改被永久保持</li>
</ul>
</li>
</ul>
</li>
<li>事务关闭<ul>
<li>默认情况下，每条单独的SQL语句视为一个事务，默认开启，即autocommit=1</li>
<li>关闭开启自动提交状态 set autocommit=0|1,0为关闭自动提交</li>
<li>关闭自动提交后，从下一条SQL语句开始则开启新事务，需使用commit或者rollback语句结束该事</li>
</ul>
</li>
</ul>
<p></p><h6>视图</h6><p></p>
<ul>
<li>视图是一张虚拟表<ul>
<li>表示一张表的部分数据或多张表的综合数据</li>
<li>其结构和数据是建立在对表的查询基础上</li>
</ul>
</li>
<li>视图中不存放数据<ul>
<li>数据存放在视图所引用的原始表中</li>
</ul>
</li>
<li>一个原始表，根据不同用户的不同需求，可以创建不同的视图</li>
<li><p>对视图数据进行添加、更新和删除操作直接影响所引用表中的数据</p>
<pre><code>#删除视图
drop view if exists view_name;
#创建视图
create view view_name(
    select ......
)
#查看视图
select ... from view_name;
</code></pre></li>
</ul>
<p></p><h6>索引</h6><p></p>
<ul>
<li>索引是一种有效组合数据的方式，为快速查找到指定记录</li>
<li>作用<ul>
<li>大大提高数据库的检索速度</li>
<li>改善数据库性能</li>
</ul>
</li>
<li><p>一般用的最多的就是主键索引和唯一索引</p>
<ul>
<li>一个主键将自动创建主键索引</li>
<li><p>索引列数据不重复UNIQUE</p>
<pre><code>create [UNIQUE] index index_stuName 
on student(studentName)

drop index index_name on table_name
#删除表时，该表的所有索引同时会被删除

show index from table_name   #查看索引
</code></pre></li>
</ul>
</li>
</ul>
<p></p><h6>备份</h6><p></p>
<ul>
<li><p>mysqldump是DOS系统下的命令，<br>在使用时无须进入mysql命令行，否则将无法执行</p>
<pre><code>mysqldump -uroot -p123456 mybank bank &gt;D:\Python\0309.sql
#备份
mysql -uroot -p123456 mybank &lt;D:\Python\0309.sql
#还原
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/09/事务视图索引备份/" data-id="cjyzyo0vi005i3cwv6cfjht2k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL学习/">MySQL学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-httpwatch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/httpwatch/" class="article-date">
  <time datetime="2018-03-08T05:49:23.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/httpwatch/">httpwatch</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>httpwatch</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>HttpWatch是一个可用于录制HTTP请求信息的工具，由Simtec Limited公司开发，其官网为：Http://www.httpwatch.com，HttpWatch只支持IE和Firefox，也就是说只有当你用IE或Firefox访问网页时，它才会进行录制，不像Sniffer和Omnipeek那样监控所有数据，但对于网站分析来说，已经是不可多得的利器了</li>
<li>HttpWatch是功能强大的网页数据分析工具，集成在IE工具栏，主要功能有网页摘要、cookies管理、缓存管理、消息头发送/接收，字符查询、POST数据、目录管理功能和报告输出。HttpWatch是一款能够收集并显示深层信息的软件，它不用代理服务器或一些复杂的网络监控工具，能够在显示网页的同时显示网页请求和回应的日志信息，甚至可以显示浏览器缓存和IE之间的交换信息，集成在IE工具栏</li>
<li>HttpWatch有两部分组成： <ul>
<li>1、一个是嵌入到IE或Firefox中用于收集、查看、保存HTTP信息的插件 </li>
<li>2、一个是独立运行的日志查看器，叫做HttpWatch Studio</li>
</ul>
</li>
</ul>
<p></p><h6>Time Chart</h6><p></p>
<ul>
<li>显示了一次请求应答过程中每个时间片段所花费的时间。一次完整的请求应答过程需要经历的时间片段如下：<br>Blocked-&gt;DNS Lookup-&gt;Connect    -&gt;Send -&gt;Wait    -&gt;Receive</li>
<li>各时间片段含义如下：<ul>
<li>Blocked（阻塞）：阻塞的时间主要包括预处理时间（如缓存查找）和网络排队等待时间，导致阻塞最主要原因是下载页面中的图片</li>
<li>DNS Lookup（域名解释）：域名解释时间主要是将主机名（如www.google.com）转化为相应的IP地址（216.239.59.99）的时间，在访问URL地址时，地址本身不能被直接访问，需要将它对应为相应的IP地址才能访问</li>
<li>Connect（连接）：连接时间是指与web服务器（或代理服务器）建立起TCP连接需要的时间，一个安全的HTTPS连接应该包含SSL握手的过程，让系统处于一种保持连接的状态，可以节约重复创建TCP连接的时间</li>
<li>Send（发送）：发送时间是指从客户端发送HTTP请求到服务器所花费的时间，并且发送数据大小会影响发送的时间，如上传文件花费的时间就比较长</li>
<li>Wait（等待）：等待时间是指服务器响应请求的时间，这个值包括网络延迟和服务器处理请求所花费的时间</li>
<li>Receive（接收）：接收时间是指服务器返回数据到客户端所花费的时间，这个时间受所返回消息内容大小、网络带宽和HTTP压缩比的影响</li>
<li>Cache Read（读cache）：读缓存时间是指从浏览器缓存中读取内容的时间</li>
</ul>
</li>
</ul>
<p></p><h6>Headers</h6><p></p>
<ul>
<li><p>Headers Sent的内容如下：</p>
<ul>
<li>(Request-Line)：包括HTTP提交请求方法、HTTP版本和URL子路径</li>
<li>Accept：可接受的文件类型，<em>/</em>表示所有</li>
<li>Accept-Encoding：可接受的纯文本之外的内容编码的类型</li>
<li>Accept-Language：可接受的返回数据的语言种类</li>
<li>Connection：指定该次请求回应结束后，如何处理连接</li>
<li>Cache-Control：指定请求和响应遵循的缓存机制</li>
<li>Location：用于重定向接收者到一个新URL地址</li>
<li>Host：请求连接的主机名</li>
<li>User-Agent：客户端标识浏览器类型</li>
</ul>
</li>
<li><p>Headers Received的内容如下：</p>
<ul>
<li>(Status-Line)：包括HTTP请求的状态码和HTTP版本信息</li>
<li>Connection：指定该次请求回应结束后，如何处理连接</li>
<li>Content-Language：内容数据的语言种类</li>
<li>Content-Length：传输的内容长度</li>
<li>Content-Type：内容数据的类型（Mini Type）</li>
<li>Date：发送HTTP消息的日期</li>
<li>Server：一种标明Web服务器软件及其版本号的</li>
<li>X-Cache：表明你的http request是由proxy server回的</li>
<li>Last-Modified：服务器上保存内容的最后修订时间</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/httpwatch/" data-id="cjyzyo0rz003j3cwvmy2nhdal" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能测试/">性能测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-chown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/chown/" class="article-date">
  <time datetime="2018-03-08T05:48:02.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/chown/">chown</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>chown</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>1.使用权限 : root</li>
<li><p>2.使用方式</p>
<pre><code>chown[-f][-h][-R] Owner [ :Group ] { File ... | Directory ... }
chown -R [-f ][-H| -L| -P] Owner [ :Group ] { File ... | Directory ... }
</code></pre></li>
<li><p>3.说明：Linux/Unix 是多人多工作业系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥<br>有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以<br>改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才<br>有这样的权限，一个字：更改与文件关联的所有者或组</p>
</li>
<li><p>4.描述：chown命令将 File 参数指定的文件的所有者更改为 Owner 参数指定的用户。Owner 参数的值可以是可在 /etc/passwd 文件中找到的用户标识或登录名。还可以选择性地指定组。Group 参数的值可以是可在 /etc/group 文件中找到的组标识或组名</p>
<pre><code>-f
禁止除用法消息之外的所有错误消息
-h
更改遇到的符号链接的所有权，而非符号链接指向的文件或目录的所有权
当遇到符号链接而您未指定 -h 标志时，chown 命令更改链接指向的文件或目录的所有权，而非链接本身的所有权
如果指定 -R 标志，chown 命令递归地降序指定的目录
-H
如果指定了 -R 选项，并且引用类型目录的文件的符号链接在命令行上指定，
chown 变量会更改由符号引用的目录的用户标识（和组标识，如果已指定）和所有在该目录下的文件层次结构中的所有文件
-L
如果指定了 -R 选项，并且引用类型目录的文件的符号在命令行上指定或在遍历文件层次结构期间遇到，
chown 命令会更改由符号链接引用的目录的用户标识（和组标识，如果已指定）和在该目录之下的文件层次结构中的所有文件
-P
如果指定了 -R 选项并且符号链接在命令行上指定或者在遍历文件层次结构期间遇到，则如果系统支持该操作，
则chown 命令会更改符号链接的所有者标识（和组标识，如果已指定）。chown 命令不会执行至文件层次结构的任何其它部分的符号链接
-R
递归地降序目录，更改每个文件的所有权。当遇到符号链接并且链接指向目录时，更改该目录的所有权，但不进一步遍历目录。
不过 -h、-H、-L or -P 标志也未指定，则当遇到符号链接并且该链接指向到目录时，该目录的组所有权更改但不会进一步遍历目录
</code></pre></li>
</ul>
<p></p><h6>示例</h6><p></p>
<ul>
<li><p>将档案 file1.txt 的拥有者设为 users 群体的使用者 tom : </p>
<pre><code>chown tom:users file1.txt 
</code></pre></li>
<li><p>将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 jerry : </p>
<pre><code>chown -R lamport:users * 
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/chown/" data-id="cjyzyo0rq003d3cwveotzsz5v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux学习/">Linux学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Page Object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/Page Object/" class="article-date">
  <time datetime="2018-03-08T03:30:46.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/Page Object/">Page Object</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>Page Object</h5><p></p>
<hr>
<hr>
<p></p><h6>By元素定位</h6><p></p>
<ul>
<li><p>已经将By方法封装</p>
<pre><code>from selenium import webdriver
from selenium.webdriver.common.by import By

driver=webdriver.Firefox()
driver.get(&apos;http://www.baidu.com&apos;)
driver.find_element(By.ID,&apos;kw&apos;).clear()
driver.find_element(By.NAME,&apos;wd&apos;).send_keys(&apos;selenium&apos;)
driver.find_element(By.CLASS_NAME,&apos;s_ip&apos;).send_keys(&apos;study&apos;)
driver.find_element(By.CSS_SELECTOR,&apos;#kw&apos;).send_keys(&apos;Python&apos;)
driver.find_element(By.TAG_NAME,&apos;input&apos;)....
driver.find_element(By.LINK_TEXT,&apos;退出&apos;)...
driver.find_element(By.PARTIAL_LINK_TEXT,&apos;退&apos;)...
driver.find_element(By.XPATH,&apos;.//[@id=&quot;Title&quot;]&apos;)...
</code></pre></li>
</ul>
<p></p><h6>Page Object</h6><p></p>
<ul>
<li><p>Page Object是Selenium自动化测试项目开发实践的最佳设计模式之一，通过对界面元素和功能模块的封装减少冗余代码，同时在后期维护中，若元素定位或功能模块发生变化，只需要调整页面元素或功能模块封装的代码，提高测试用例的可维护性</p>
<pre><code>#basepage.py
from time import sleep
class Page:                         #页面基础类
    def __init__(self,driver):      #初始化
        self.driver=driver
        self.base_url=&apos;http://localhost&apos;
        self.timeout=10
    def _open(self,url):            #打开不同的子页面
        url_=self.base_url+url
        print(&apos;Test page is %s&apos;%url_)
        self.driver.maximize_window()
        self.driver.get(url_)
        sleep(3)
        assert self.driver.current_url==url_,&apos;Did not land on %s&apos;%url_
    def open(self):
        self._open(self.url)
    def find_element(self,*location): #元素定位方法封装
        return self.driver.find_element(*location)

#loginpage.py
from basepage import *
from selenium.webdriver.common.by import By
class LoginPage(Page):
    &apos;&apos;&apos;首页登录页面&apos;&apos;&apos;
    url=&apos;/&apos;
    username_loc=(By.NAME,&apos;username&apos;)         #定位器
    password_loc=(By.NAME,&apos;password&apos;)
    submit_loc=(By.NAME,&apos;Submit&apos;)
    def type_username(self,username):         #用户名输入框元素
        self.find_element(*self.username_loc).clear()
        self.find_element(*self.username_loc).send_keys(username)
    def type_password(self,password):         #密码输入框元素
        self.find_element(*self.password_loc).send_keys(password)
    def type_submit(self):                    #登录按钮元素
        self.find_element(*self.submit_loc).click()

def test_user_login(driver,username,password):#登录功能模块封装
    &apos;&apos;&apos;测试用户名密码是否可以登录&apos;&apos;&apos;
    login_page=LoginPage(driver)
    login_page.open()
    login_page.type_username(username)
    login_page.type_password(password)
    login_page.type_submit()

# test_login.py
from loginpage import *
from selenium import webdriver
driver=webdriver.Firefox()
username=&apos;51zxw&apos;
password=&apos;123456&apos;

test_user_login(driver,username,password)
sleep(3)
driver.quit()
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/Page Object/" data-id="cjyzyo0r700323cwvmt224k95" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-整合测试报告发送" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/整合测试报告发送/" class="article-date">
  <time datetime="2018-03-07T01:13:05.000Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/整合测试报告发送/">整合测试报告发送</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>整合测试报告发送</h5><p></p>
<hr>
<hr>
<p></p><h6>将生成的最新测试报告发送到指定邮箱</h6><p></p>
<ul>
<li>文件路径如下：<ul>
<li>文件夹test_baidu<ul>
<li>文件夹test_case<ul>
<li>test_baidu.py</li>
</ul>
</li>
<li>文件夹test_report</li>
<li>文件send_test_email.py</li>
</ul>
</li>
</ul>
</li>
<li><p>send_test_email.py</p>
<pre><code>import unittest,time,smtplib,os
from BSTestRunner import BSTestRunner
from email.mime.text import MIMEText
from email.header import Header

def latest_report(report_dir):      #获取最新生成的测试报告
    lists=os.listdir(report_dir)
    lists.sort(key=lambda fn:os.path.getatime(report_dir+&apos;\\&apos;+fn))
    file=os.path.join(report_dir,lists[-1])
    return file
def send_mail(latest_report):       #发送邮件
    f=open(latest_report,&apos;rb&apos;)
    mail_content=f.read()
    f.close()

    smtpserver=&apos;smtp.163.com&apos;
    user=&apos;www_liuyongqian@163.com&apos;
    password=&apos;39a39b39c&apos;

    sender=&apos;www_liuyongqian@163.com&apos;
    receives=[&apos;272501447@qq.com&apos;,&apos;liuyongqian51@163.com&apos;]

    subject=&apos;Web 自动化测试结果&apos;

    msg=MIMEText(mail_content,&apos;html&apos;,&apos;utf-8&apos;)     #邮件正文
    msg[&apos;Subject&apos;]=Header(subject,&apos;utf-8&apos;)
    msg[&apos;From&apos;]=sender
    msg[&apos;To&apos;]=&apos;,&apos;.join(receives)

    smtp=smtplib.SMTP_SSL(smtpserver,465)
    smtp.helo(smtpserver)
    smtp.ehlo(smtpserver)
    smtp.login(user,password)

    print(&apos;Start send eamil...&apos;)
    smtp.sendmail(sender,receives,msg.as_string())
    smtp.quit()
    print(&apos;Send email end...&apos;)

if __name__==&apos;__main__&apos;:
    test_dir=&apos;./test_case&apos;
    report_dir=&apos;./test_report&apos;
    discovery=unittest.defaultTestLoader.discover(test_dir,pattern=&apos;test*.py&apos;)
    now=time.strftime(&apos;%Y-%m-%d %H_%M_%S&apos;)
    report_name=report_dir+&apos;/&apos;+now+&apos;result.html&apos;

    with open(report_name,&apos;wb&apos;) as f:
        runner=BSTestRunner(stream=f,title=&apos;Test Report&apos;,description=&apos;baidu search&apos;)
        runner.run(discovery)
    f.close()

    latest_report=latest_report(report_dir)  #获取最新测试报告
    send_mail(latest_report)                 #发送邮件报告
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/整合测试报告发送/" data-id="cjyzyo0z1007h3cwvenxaxhlj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-高级查询" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/06/高级查询/" class="article-date">
  <time datetime="2018-03-06T12:16:05.000Z" itemprop="datePublished">2018-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/06/高级查询/">高级查询</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>高级查询</h5><p></p>
<hr>
<hr>
<p></p><h6>其他查询</h6><p></p>
<ul>
<li><p>IN，NOT IN（可返回多条记录）</p>
<pre><code>#查询学号为009最低分的课程名
select kcm from kcb
where kch in(
    select kch from cjb
    where cj in(
        select MIN(cj) from cjb
        where xh=&apos;009&apos;
    )and xh=&apos;009&apos;
)
</code></pre></li>
<li><p>LIMIT m,n<br>m表示从m+1条开始取值，n表示条数（在语句末尾取记录）</p>
</li>
<li><p>IS NULL，IS NOT NULL</p>
<pre><code>select kch from cjb 
where cj is not nul
</code></pre></li>
</ul>
<p></p><h6>分组查询</h6><p></p>
<ul>
<li><p>GROUP BY … HAVING…</p>
<pre><code>#统计每个班级人数且人数在30人以上的
select bj as &apos;班级&apos;,count(*) as &apos;人数&apos;
from xsb
group by bj
having count(*)&gt;30 
</code></pre></li>
<li><p>在SELECT语句中，WHERE、GROUP BY、HAVING子句的执行次序如下：</p>
<pre><code>* 1、WHERE子句从数据源中去掉不符合其搜索条件的数据
* 2、GROUP BY子句搜集数据行到各个组中
* 3、HAVING子句去掉不符合其组搜索条件的各组数据行
</code></pre></li>
</ul>
<p></p><h6>多表查询</h6><p></p>
<ul>
<li><p>等值连接（先连接后判断）</p>
<pre><code>#查询张三的数据库的成绩
select xm,kcm,cj
from xsb,kcb,cjb
where xsb.xh=cjb.xh and kcb.kch=cjb.kch
#主表1.主键=从表.外键，主表2.主键=从表.外键
and xm=&apos;张三&apos; and kcm=&apos;数据库&apos;
</code></pre></li>
<li>注：查询显示字段或者其他条件中字段在几张表内有重复，需要在字段前加上表名，表名.字段名</li>
<li><p>内连接（先判断再连接）</p>
<pre><code>#查询不是北京、上海的学生的QTP成绩
select kcm,cj,jg
from xsb inner join cjb on xsb.xh=cjb.xh
inner join kcb on kcb.kch=cjb.kch
and jg not in(&apos;北京&apos;,&apos;上海&apos;)
and kcm=&apos;QTP&apos;
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/06/高级查询/" data-id="cjyzyo11l008p3cwvsklsk213" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL学习/">MySQL学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-发送邮件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/发送邮件/" class="article-date">
  <time datetime="2018-03-05T02:06:34.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/发送邮件/">发送邮件</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>发送邮件</h5><p></p>
<hr>
<hr>
<h6>python里的smtplib</h6>

<ul>
<li>SMTP(Simple Mail Transfer Protocol)<ul>
<li>即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器</li>
</ul>
</li>
<li>SMTP 认证<ul>
<li>简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机</li>
</ul>
</li>
<li>smtplib模块<ul>
<li>Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件</li>
<li>Python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件</li>
<li>使用前需要开启SMTP服务</li>
</ul>
</li>
</ul>
<h6>使用163邮箱来结合smtp模块发送邮件</h6>

<pre><code>import smtplib                         #发送邮件模块
from email.mime.text import MIMEText   #定义邮件内容
from email.header import Header        #定义邮件标题

smtpserver=&apos;smtp.163.com&apos;              #发送邮箱服务器
user=&apos;www_liuyongqian@163.com&apos;         #发送邮箱用户的账号和授权密码
password=&apos;*********&apos;

sender=&apos;www_liuyongqian@163.com&apos;       #发送邮箱
receive=&apos;272501447@qq.com&apos;             #接收邮箱

content=&apos;&lt;html&gt;&lt;h1 style=&quot;color:red&quot;&gt;这个就是我，不一样的模样&lt;/h1&gt;&lt;/html&gt;&apos;
subject=&apos;Web 自动化测试报告&apos;
msg=MIMEText(content,&apos;html&apos;,&apos;utf-8&apos;)   #发送邮件内容
#MIMEText三个参数：第一个为文本内容，第二个设置文本格式，第三个设置编码
msg[&apos;Subject&apos;]=Header(subject,&apos;utf-8&apos;) #发送邮件标题
msg[&apos;From&apos;]=sender                     #发送人
msg[&apos;To&apos;]=receive                      #收件人

smtp=smtplib.SMTP_SSL(smtpserver,465)  #SSL协议端口要是用465
smtp.helo(smtpserver)                  #helo向服务器标识用户身份
smtp.ehlo(smtpserver)                  #服务器返回结果确认
smtp.login(user,password)              #登录邮箱服务器的账号和授权密码

print(&apos;Start send eamil...&apos;)
smtp.sendmail(sender,receive,msg.as_string())
#sendmail的三个参数：邮件发送者地址，邮件接收地址可为列表，发送消息
smtp.quit()
print(&apos;Send email end...&apos;)
</code></pre><h6>发送带附件的邮件</h6>

<pre><code>import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart   #用于传输附件

smtpserver=&apos;smtp.163.com&apos;
user=&apos;www_liuyongqian@163.com&apos;
password=&apos;39a39b39c&apos;

sender=&apos;www_liuyongqian@163.com&apos;
receives=[&apos;272501447@qq.com&apos;,&apos;liuyongqian51@163.com&apos;]

subject=&apos;web自动化测试报告0308&apos;
content=&apos;&lt;html&gt;&lt;p&gt;这个里面写测试结果内容！&lt;/p&gt;&lt;/html&gt;&apos;

send_file=open(r&apos;E:\selenium prt\test.jpg&apos;,&apos;rb&apos;).read()  #构造附件内容
att=MIMEText(send_file,&apos;base64&apos;,&apos;utf-8&apos;)
att[&apos;Content-Type&apos;]=&apos;application/octet-stream&apos;
att[&apos;Content-Disposition&apos;]=&apos;attachment;filename=&quot;test.jpg&quot;&apos;

msgRoot=MIMEMultipart()                             #构建发送与接收信息
msgRoot.attach(MIMEText(content,&apos;html&apos;,&apos;utf-8&apos;))
msgRoot[&apos;Subject&apos;]=subject
msgRoot[&apos;From&apos;]=sender
msgRoot[&apos;To&apos;]=&apos;,&apos;.join(receives)
msgRoot.attach(att)

smtp=smtplib.SMTP_SSL(smtpserver,465)
smtp.helo(smtpserver)
smtp.ehlo(smtpserver)
smtp.login(user,password)
print(&apos;Start send email...&apos;)
smtp.sendmail(sender,receives,msgRoot.as_string())
smtp.quit()
print(&apos;End send email...&apos;)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/05/发送邮件/" data-id="cjyzyo0wa00603cwvnwghszkw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-单元测试框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/04/单元测试框架/" class="article-date">
  <time datetime="2018-03-04T14:12:42.000Z" itemprop="datePublished">2018-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/04/单元测试框架/">单元测试框架</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>单元测试框架</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>单元测试（unit testing）是指对软件中的最小可测试单元进行检查和验证，单元就是人为规定的最小的被测功能模块</li>
<li>单元测试框架提供了一种统一的编程模型，可以将测试定义为一些简单的类，这些类中的方法可以调用希望测试的应用程序代码。</li>
<li>不同编程语言有不同的单元测试框架，如Java 的Junit, TestNg, c#的 Nunit,Python的unittest,Pyunit,testtools, subunit….</li>
</ul>
<p></p><h6>unittest</h6><p></p>
<ul>
<li>unittest单元测试框架不仅适用于单元测试，还适用WEB自动化测试用例的开发与执行，该测试框架可组织执行测试用例，并且提供了丰富的断言方法，判断测试用例是否通过，最终生成测试结果</li>
<li>unittest核心要素<ul>
<li>TestCase<br>一个TestCase的实例就是一个测试用例。什么是测试用例呢？就是一个完整的测试流程，包括测试前准备环境的搭建(setUp)，执行测试代码(run)，以及测试后环境的还原(tearDown)。单元测试(unit test)的本质也就在这里，一个测试用例是一个完整的测试单元，通过运行这个测试单元，可以对某一个问题进行验证</li>
<li>TestSuite<br>而多个测试用例集合在一起，就是TestSuite，而且TestSuite也可以嵌套TestSuite。 TestLoader是用来加载TestCase到TestSuite中的，其中有几个loadTestsFrom__()方法，就是从各个地方寻找TestCase，创建它们的实例，然后add到TestSuite中，再返回一个TestSuite实例</li>
<li>TextTestRunner<br>TextTestRunner是来执行测试用例的，其中的run(test)会执行TestSuite/TestCase中的run(result)方法。测试的结果会保存到TextTestResult实例中，包括运行了多少测试用例，成功了多少，失败了多少等信息</li>
<li>Fixture<br>对一个测试用例环境的搭建和销毁，是一个fixture</li>
</ul>
</li>
<li><p>unittest案例</p>
<pre><code>#cal.py #加减法运算方法的实现
class Math:
    def __init__(self,a,b):
        self.a=int(a)
        self.b=int(b)
    def add(self):
        return self.a+self.b
    def sub(self):
        return self.a-self.b
#startend.py #SetUp与TearDown管理
import unittest
class StartEnd(unittest.TestCase):
    def setUp(self):
        print(&apos;开始测试！&apos;)
    def tearDown(self):
        print(&apos;测试结束！&apos;)
#test_add.py #加法测试用例
from cal import *
from startend import *
class Test_add(StartEnd):
    def test_add(self):
        j=Math(6,9)
        self.assertEqual(j.add(),15)
    def test_add1(self):
        k=Math(5,7)
        self.assertEqual(k.add(),12)
#test_sub.py #减法测试用例
from cal import *
from startend import *
class Test_sub(StartEnd):
    def test_sub(self):
        j=Math(6,9)
        self.assertEqual(j.sub(),-3)
    def test_sub1(self):
        k=Math(5,7)
        self.assertEqual(k.sub(),-2)
#runtest.py #用例执行管理
import unittest
dir=&apos;./&apos;
discovery=unittest.defaultTestLoader.discover(dir,pattern=&apos;test*.py&apos;)
if __name__==&apos;__main__&apos;:
    runner=unittest.TextTestRunner()
    runner.run(discovery)
</code></pre></li>
<li><p>断言<br>断言内容是自动化脚本的重要内容，正确设置断言以后才能帮助我们判断测试用例执行结果</p>
<pre><code>assertEqual(a, b) 判断a==b
assertNotEqual(a, b) 判断a！=b
assertTrue(x) bool(x) is True
assertFalse(x) bool(x) is False
assertIs(a, b) a is b
assertIsNot(a, b) a is not b
assertIsNone(x) x is None
assertIsNotNone(x) x is not None
assertIn(a, b) a in b
assertNotIn(a, b) a not in b
assertIsInstance(a, b) isinstance(a, b)
assertNotIsInstance(a, b) not isinstance(a, b)
</code></pre></li>
<li><p>跳过测试和预期失败</p>
<pre><code>unittest.skip() 直接跳过测试
unittest.skipIf() 条件为真，跳过测试
unittest.skipUnless 条件为假，跳过测试
unittest.expectedFailure 预期设置失败

import unittest
class test1(unittest.TestCase):
    def setUp(self):
        print(&apos;测试开始!&apos;)
    def test_b(self):
        print(&apos;test_b&apos;)
    @unittest.skipIf(3&lt;4,&apos;skip test_c&apos;)
    def test_c(self):
        print(&apos;test_c&apos;)
    def tearDown(self):
        print(&apos;测试结束!&apos;)
@unittest.skip(&apos;skip test2&apos;)
class test2(unittest.TestCase):
    def setUp(self):
        print(&apos;测试开始！&apos;)
    def test_d(self):
        print(&apos;test_d&apos;)
    def test_a(self):
        print(&apos;test_a&apos;)
    def tearDown(self):
        print(&apos;测试结束!&apos;)
if __name__==&apos;__main__&apos;:
    unittest.main()
</code></pre></li>
</ul>
<p></p><h6>编写Web测试用例</h6><p></p>
<ul>
<li><p>案例：百度搜索关键词：“Selenium自学网” 并打开课程页面</p>
<pre><code>#test_baidu.py
from selenium import webdriver
import unittest
from time import sleep
class TestBaidu(unittest.TestCase):
    def setUp(self):
        self.driver=webdriver.Firefox()
        #self.driver.implicitly_wait(10)
        self.driver.get(&apos;http://www.baidu.com/&apos;)
    def test_baidu(self):
        driver=self.driver
        driver.find_element_by_id(&apos;kw&apos;).clear()
        driver.find_element_by_id(&apos;kw&apos;).send_keys(&apos;selenium自学网&apos;)
        driver.find_element_by_id(&apos;su&apos;).click()
        sleep(3)
        title=driver.title
        self.assertEqual(title,&apos;selenium自学网_百度搜索&apos;)
        driver.find_element_by_partial_link_text(&apos;Selenium自动化&apos;).click()
        sleep(5)
    def tearDown(self):
        self.driver.quit()
if __name__==&apos;__main__&apos;:
    unittest.main()
#runtest.py
import unittest
#from HTMLTestRunner import HTMLTestRunner
from BSTestRunner import BSTestRunner
import time

test_dir=&apos;./test_case&apos;          #定义测试用例路径
discovery=unittest.defaultTestLoader.discover(test_dir,pattern=&apos;test*.py&apos;)

if __name__==&apos;__main__&apos;:
    report_dir=&apos;./test_report&apos;  #存放报告的文件夹
    now=time.strftime(&apos;%Y-%m-%d %H_%M_%S&apos;)       #报告命名时间格式化
    report_name=report_dir+&apos;/&apos;+now+&apos;result.html&apos; #报告文件完整路径
    #打开文件在报告文件中写入测试结果
    with open(report_name,&apos;wb&apos;) as f:
        #runer=HTMLTestRunner(stream=f,title=&apos;Test Report&apos;,description=&apos;Test case result&apos;)
        runner=BSTestRunner(stream=f,title=&apos;Test Report&apos;,description=&apos;Test case result&apos;)
        runner.run(discovery)
    f.close()
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/04/单元测试框架/" data-id="cjyzyo0wl00683cwv8axq2z0i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/12/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django学习/">Django学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA项目部署/">JAVA项目部署</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux学习/">Linux学习</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL学习/">MySQL学习</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx学习/">Nginx学习</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL学习/">NoSQL学习</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python学习/">Python学习</a><span class="tag-list-count">27</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web前端/">Web前端</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全测试/">安全测试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫学习/">爬虫学习</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络基础知识/">网络基础知识</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化测试/">自动化测试</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工具/">软件工具</a><span class="tag-list-count">6</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django学习/" style="font-size: 11.11px;">Django学习</a> <a href="/tags/JAVA项目部署/" style="font-size: 16.67px;">JAVA项目部署</a> <a href="/tags/Linux学习/" style="font-size: 17.78px;">Linux学习</a> <a href="/tags/MySQL学习/" style="font-size: 18.89px;">MySQL学习</a> <a href="/tags/Nginx学习/" style="font-size: 10px;">Nginx学习</a> <a href="/tags/NoSQL学习/" style="font-size: 15.56px;">NoSQL学习</a> <a href="/tags/Python学习/" style="font-size: 20px;">Python学习</a> <a href="/tags/Web前端/" style="font-size: 14.44px;">Web前端</a> <a href="/tags/大数据/" style="font-size: 12.22px;">大数据</a> <a href="/tags/安全测试/" style="font-size: 10px;">安全测试</a> <a href="/tags/性能测试/" style="font-size: 14.44px;">性能测试</a> <a href="/tags/爬虫学习/" style="font-size: 15.56px;">爬虫学习</a> <a href="/tags/网络基础知识/" style="font-size: 10px;">网络基础知识</a> <a href="/tags/自动化测试/" style="font-size: 13.33px;">自动化测试</a> <a href="/tags/软件工具/" style="font-size: 12.22px;">软件工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/06/磁盘挂载/">磁盘挂载</a>
          </li>
        
          <li>
            <a href="/2019/08/06/配置MongoDB访问账号-密码/">配置MongoDB访问账号&amp;密码</a>
          </li>
        
          <li>
            <a href="/2019/05/28/读书乱纪01/">笔记01</a>
          </li>
        
          <li>
            <a href="/2019/05/11/mysql日志文件/">mysql日志文件</a>
          </li>
        
          <li>
            <a href="/2019/05/11/Nginx日志文件/">Nginx日志文件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
       Email:<a>liuyongqian51@163.com</a><br />
          QQ:<a>272501447</a><br />
	  Github:<a></a>
    </div>
  </div>

  
  

</aside>


        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 刘永前<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>

</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>