<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>LiuYongQian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="永远相信美好的事情将要发生！">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongQian">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="LiuYongQian">
<meta property="og:description" content="永远相信美好的事情将要发生！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongQian">
<meta name="twitter:description" content="永远相信美好的事情将要发生！">
  
    <link rel="alternate" href="/atom.xml" title="LiuYongQian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongQian</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">永远相信美好的事情将要发生！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-发布及文件上传" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/01/发布及文件上传/" class="article-date">
  <time datetime="2018-04-01T09:47:40.000Z" itemprop="datePublished">2018-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/01/发布及文件上传/">发布及文件上传</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>发布及文件上传</h5><p></p>
<hr>
<hr>
<p></p><h6>发布博客</h6><p></p>
<ul>
<li><p>用户登录之后，点击“发布博客”即可进入发布博客页面，在这儿需要在登录的欢迎页面增加一下这个发布博客链接</p>
<pre><code>&lt;a href=&quot;/pyblogA/fabu&quot;&gt;发布博客&lt;a/&gt;
</code></pre></li>
<li><p>之后编辑发布博客的前端页面</p>
<pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;欢迎发布博客&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;欢迎{{ user.username }}发布博客...&lt;/h2&gt;
    &lt;span style=&quot;color:red&quot;&gt;{{ msg }}&lt;/span&gt;
    &lt;form action=&quot;/pyblogA/fabu&quot; method=&quot;post&quot;&gt;
        {% csrf_token %}
        &lt;p&gt;标题：&lt;input type=&quot;text&quot; name=&apos;title&apos; style=&quot;width:300px&quot;&gt;&lt;/p&gt;
        &lt;p&gt;内容：&lt;textarea  name=&apos;context&apos; style=&quot;width:300px;height:200px&quot;&gt;&lt;/textarea&gt;&lt;/p&gt;
        &lt;input type=&quot;submit&quot; value=&quot;确认发布&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
<li><p>在该app的models中编辑与数据库的映射</p>
<pre><code>from django.db import models
from bloguser.models import BlogUser
class Blog(models.Model):
    title=models.CharField(max_length=30,null=True)
    context=models.CharField(max_length=500,null=True)
    createDate=models.DateTimeField(null=True)    #默认当前时间
    BlogUser=models.ForeignKey(&apos;bloguser.BlogUser&apos;,on_delete=None)   #app下的名字
</code></pre></li>
<li><p>需要在项目的settings.py下设置路径</p>
<pre><code>urlpatterns = [
    path(&apos;pyblogA/&apos;,include(&apos;pyblogA.urls&apos;)),
]
</code></pre></li>
<li><p>接着在该app的urls下设置路径</p>
<pre><code>urlpatterns = [
    path(&apos;fabu&apos;, fabu),
]
</code></pre></li>
<li><p>接下来编辑该appviews内容</p>
<pre><code>from django.shortcuts import render,redirect,reverse
from .models import *
from django.http import HttpResponse
import time,datetime,os

def fabu(request):
    user = request.session.get(&apos;user&apos;, None)
    if request.method==&apos;GET&apos;:
        if user is not None:
            return render(request,&apos;fabu.html&apos;,{&apos;user&apos;: request.session.get(&apos;user&apos;, None)})
        else:
            return render(request,&apos;login.html&apos;)
    elif request.method==&apos;POST&apos;:
        blogA=Blog()
        blogA.title=request.POST.get(&apos;title&apos;)
        blogA.context=request.POST.get(&apos;context&apos;)
        blogA.createDate=datetime.datetime.now()

        uid=request.session.get(&apos;user&apos;)[&apos;id&apos;]
        bloguserset=BlogUser.objects.filter(pk=uid).all()
        blogA.BlogUser=bloguserset.first()

        blogA.save()
        ret={&apos;msg&apos;:&apos;发布成功！&apos;,&apos;user&apos;:request.session.get(&apos;user&apos;)}
        return render(request,&apos;fabu.html&apos;,ret)
</code></pre></li>
</ul>
<p></p><h6>文件上传</h6><p></p>
<ul>
<li><p>创建一个html文件用于上传文件</p>
<pre><code>&lt;form method=&quot;post&quot; action=&quot;/pyblogA/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;
    {% csrf_token %}
    选择文件：&lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;
&lt;/form&gt;
</code></pre></li>
<li><p>在该app下设置路径</p>
<pre><code>urlpatterns = [
    path(&apos;upload&apos;, upload),
]
</code></pre></li>
<li><p>在该app的views中编辑业务逻辑</p>
<pre><code>def upload(request):
    myfile=request._files.get(&apos;myfile&apos;)  #获取上传的文件
    file_path=os.path.join(&apos;file&apos;,myfile.name)  #配置存放路径为file
    file=open(file_path,&apos;wb+&apos;)           #打开并写入
    for row in myfile.chunks():      #循环chunks(),里面包含用户上传的文件
        file.write(row)              #写入到我们创建的那个文件中
    file.close()
    return HttpResponse(&apos;上传成功！&apos;)
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/01/发布及文件上传/" data-id="ck6x5spjn006jkcwvpn1fyeyt" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django学习/">Django学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-HTTP报文" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/01/HTTP报文/" class="article-date">
  <time datetime="2018-04-01T03:15:03.000Z" itemprop="datePublished">2018-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/01/HTTP报文/">HTTP报文</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>HTTP报文</h5><p></p>
<hr>
<hr>
<p></p><h6>定义</h6><p></p>
<ul>
<li>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的<br>HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。<br>HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文<br>本</li>
<li><p>一个HTTP报文由3部分组成，分别是:起始行（start line）、首部（header）、主体（body），样子就像这个：</p>
<pre><code>#请求报文的格式：                       #响应报文的格式：
&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;       &lt;version&gt; &lt;status&gt;&lt;reason-phrase&gt;
&lt;headers&gt;                              &lt;headers&gt;

&lt;entity-body&gt;                          &lt;entity-body&gt;
</code></pre></li>
<li><p>格式内容概略</p>
<pre><code>##method
方法　　　　　　　　    描述　　　　　　　　      是否包含主体
GET 　　　　从服务器获取一份文档 　　　　　　　　 　   否
HEAD 　　　只从服务器获取文档的首部 　　　　　　  　　　否
POST 　　   向服务器发送需要处理的数据　　　　　　　　　是
PUT 　　　　将请求的主体部分存储在服务器上 　　　  　　 是
TRACE 　　 对可能经过代理服务器传送到服务器上去的报文进行跟踪 　　否
OPTIONS 　 决定可以在服务器上执行哪些方法 　　　　　　  否
DELETE 　　从服务器上删除一份文档 　　　　　　　　　　  否   

##request-URL   
命名了所有请求资源，或者URL路径组件的完整URL，
一个完整的包括类型、主机名和可选路径名的统一资源引用名，
如：http://www.example.com/path/to/file.html

##version
报文所使用的HTTP版本，其格式如：HTTP/&lt;major&gt;.&lt;minor&gt;
其中主要版本号(major)和次要版本号(minor)都是整数，如：HTTP/1.1

##status、reason-phrase
状态码                类别                原因短语
1XX Informational（信息性状态码）     接收的请求正在处理
2XX Success        （成功状态码）         请求正常处理完毕
3XX Redirection（重定向状态码）          需要进行附加操作以完成请求
4XX Client Error（客户端错误状态码）  服务器无法处理请求
5XX Server Error（服务器错误状态码）  服务器处理请求出错

##headers
可以有0个或多个首部，每个首部都包含一个名字，后面跟着一个冒号(:)，然后是一个可选的空格，接着是一个值，最后是一个CRLF

##entity-body
实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分。如GET请求就不包含实体
</code></pre></li>
</ul>
<p></p><h6>headers-首部分类</h6><p></p>
<ul>
<li><p>通用首部</p>
<ul>
<li>既可以出现在请求报文中，也可以出现在响应报文中</li>
<li><p>通用的信息性首部：</p>
<pre><code>    首部 　　　　　　　　　　        描述
Connection 　　　　　　  允许客户端和服务器指定与请求/响应连接有关的选项
Date 　　　　　　　　　   提供日期和时间标志，说明报文是什么时间创建的
MIME-Version 　　　　　  给出了发送端使用的MIME版本
Trailer 　　　　　　　　　如果报文采用了分块传输编码(chunked transfer encoding)方式，就可以用这个首部列出位于报文拖鞋 (trailer)部分的首部集合。
Transfer-Encoding 　　  告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。
Update 　　　　　　　　   给出了发送端可能想要&quot;升级&quot;使用的新版本或协议
Via 　　　　　　　　　　   显示了报文经过的中间节点(代理、网关)
</code></pre></li>
<li><p>通用缓存首部：</p>
<pre><code>    首部 　　　　　　　　　　描述
Cache-Control 　　　　  用于随报文传送缓存指示
Pragma 　　　　　　　　  另一种随报文传送指示的方式，但并不专用于缓存
</code></pre></li>
</ul>
</li>
<li><p>请求首部</p>
<ul>
<li>请求首部是在请求报文中有意义的首部。用于说明是谁或什么在发送请求，请求源自何处，或者客户端的喜好及能力。服务器可以根据请求首部给出的客户端的信息，试着为客户端提供更好的响应</li>
<li><p>请求的信息性首部：</p>
<pre><code>    首部 　　　　　　　　　　　　 描述
Client-IP 　　　　　　　　　提供了运行客户端的机器的IP地址
From 　　　　　　　　　　　 提供了客户端用户的E-mail地址
Host 　　　　　　　　　　　 给出了接收请求的服务器的主机名和端口号
Referer 　　　　　　　　　　提供了包含当前请求URI的文档的URL
UA-Color 　　　　　　　　　 提供了与客户端显示器的显示颜色有关的信息
UA-CPU 　　　　　　　　　　 给出了客户端CPU的类型或制造商
US-Disp 　　　　　　　　　　提供了与客户端显示器(屏幕)能力有关的信息
US-OS 　　　　　　　　　　  给出了客户端显示器的像素信息
UA-Pixels 　　　　　　　　　提供了客户端显示器的像素信息
User-Agent 　　　　　　　　 将发起请求的应用程序名称告知服务器(User-Agent)用户代理，其实不就是浏览器吗
</code></pre></li>
<li><p>Accept首部<br>Accept首部为客户端提供了一种将其喜好和能力告知服务器的方式，包括他们想要什么，可以使用什么，以及最重要的，他们不想要什么。这样服务器就可以根据这些额外信息，对要发送的内容做出更明智的决定。Accept首部会使连接的两端都受益。客户端会得到他们想要的内容，服务器则不会浪费其时间和带宽来发送客户端无法使用的东西</p>
<pre><code>    首部 　　　　　　　　　　 描述
Accept 　　　　　　　　   告诉服务器能够发送哪些媒体类型
Accept-Charset 　　　　  告诉服务器能够发送哪些字符集
Accept-Encoding 　　　　 告诉服务器能够发送哪些编码方式
Accept-Language 　　　   告诉服务器能够发送哪些语言
TE 　　　　　　　　　　　  告诉服务器可以使用哪些扩展传输编码
</code></pre></li>
<li><p>条件请求首部<br>有时客户端希望为请求加上某些限制。比如客户端已经有了一份副本，就希望只在服务器上的文档与客户端拥有的副本有所区别时，才请求服务器传输文档。通过条件请求首部，客户端就可以加上这种限制，要求服务器在对请求进行相应之前，确保某个请求为真</p>
<pre><code>    首部 　　　　　　　　　　 描述
Expect 　　　　　　　　  允许客户端列出某请求所要求的服务器行为
If-Match 　　　　　　　　如果实体标记与文档当前的实体标记相匹配，就或者这份文档
If-Modified-Since 　　　除非在某个指定的日期之后资源被修改过，否则就限制这个请求
If-Range 　　　　　　　　允许对文档的某个范围进行条件请求
If-Unmodified-Since 　　除非在某个指定的日期之后资源没有被修改过，否则就限制这个请求
Range 　　　　　　　　　 如果服务器支持范围请求，就请求资源的指定范围
</code></pre></li>
<li><p>安全请求首部<br>HTTP本身就支持一种简单的机制，可以对请求进行质询/响应认证。这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全一些</p>
<pre><code>    首部 　　　　　　　　　　 描述
Authorization 　　　　　 包含了客户端提供给服务器，以便对其自身进行认证的数据
Cookie 　　　　　　　　　 客户端用它想服务器传送一个令牌-他并不是真正的安全首部，但却是隐含了安全功能
Cookie2 　　　　　　　　  用来说明请求端支持的cookie版本
</code></pre></li>
<li><p>代理请求首部<br>随着因特网上代理的普遍应用，人们定义了几个首部来协助其更好地工作</p>
<pre><code>    首部 　　　　　　　　　　 描述
Max-Forword 　　　　　   在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数-与TRACE方法一同使用
Proxy-Authorization 　　与Authorization首部相同，但这个首部是在与代理进行认证时使用的
Proxy-Connection 　　　 与Connection首部相同，但这个首部是在于代理建立连接时使用的
</code></pre></li>
</ul>
</li>
<li><p>响应首部</p>
<ul>
<li>响应首部为客户端提供了一些额外的信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些首部有助于客户端处理响应，并在将来发起更好的请求</li>
<li><p>响应的信息性首部：</p>
<pre><code>首部 　　　　　　　　     描述
Age 　　　　　　　　 (从最初创建开始)响应持续时间
Public 　　　　　　　服务器为其资源支持的请求方法列表
Retry-After 　　　　如果资源不可用的话，再次日期或时间重试
Server 　　　　　　　服务器应用程序软件的名称和版本
Title 　　　　　　　 对HTML文档来说，就是HTML文档的源端给出的标题
Warning 　　　　　　 比原因短语中更详细的一些警告报文
</code></pre></li>
<li><p>协商首部<br>如果资源有多种表示方法-比如，如果服务器上有某文档的法语和德语译稿，HTTP/1.1可以为服务器和客户端提供对资源进行协商的能力</p>
<pre><code>首部　　　　　　　　         描述
Accept-Ranges 　　 对此资源来说，服务器可接受的范围类型
Vary 　　　　　　　  服务器查看的其他首部的列表，可能会使响应发生变化；
                   也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最合适的资源版本　　　　　　　　　　　 发送给客户端
</code></pre></li>
<li><p>安全响应首部</p>
<pre><code>      首部                              描述
Proxy-Authenticate             来自代理的对客户端的质询列表
Set-Cookie                     不是真正的安全首部，但隐含有安全功能；可以在客户端设置一个令牌，以便服务器对客户端进行标识。
Set-Cookie2                 与Set-Cookie类似。
WWW-Authenticate             来自服务器的对客户端的质询列表
</code></pre></li>
</ul>
</li>
<li><p>实体首部</p>
<ul>
<li>描述主体的长度和内容，或者资源自身</li>
<li>由于请求和响应文本中都可能包含实体部分，所以在这两种类型的报文中都可能出现这些首部。实体首部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体首部可以告知报文的接收者它在对什么进行处理</li>
<li><p>实体信息性首部:</p>
<pre><code>首部 　　　　　　　        描述
Allow 　　　　　　  列出了可以对此实体执行的请求方法
Location 　　　　  告知客户端实体实际上位于何处；用于将接收端定向到资源的位置上去
</code></pre></li>
<li><p>内容首部<br>内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。比如，Web浏览器可以通过查看返回的内容类型，得知如何显示对象</p>
<pre><code>    首部 　　　　　　　　　　　  描述
Content-Base 　　　　　　   解析主体中的相对URL时使用的基础URL
Content-Encoding 　　　　  对主体执行的任意编码方式
Content-Language 　　　　  理解主体时最适宜使用的自然语言
Content-Length 　　　　　  主体的长度或尺寸
Content-Location 　　　　　资源实际所处的位置
Content-MD5 　　　　　　　 主体的MD5校验
Content-Range 　　　　　　 在整个资源中此实体表示的字节范围
Content-Type 　　　　　　  这个主体的对象模型
</code></pre></li>
<li><p>实体缓存首部<br>通用的缓存首部说明了如何或什么时候进行缓存。实体的缓存首部提供了与被缓存实体有关的信息，比如验证已缓存的资源副本是否仍然有效所需的信息，以及更好地估计已缓存资源合适失效所需的线索</p>
<pre><code>首部 　　　　　　         描述
ETag 　　　　　   与此实体有关的实体标记
Expires 　　　　  实体不在有效，要从原始的源端再次获取此实体的日期和时间
Last-Modified 　 这个实体最后一次被修改的日期和时间
</code></pre></li>
</ul>
</li>
<li><p>以上参考大神佳作<a href="https://blog.csdn.net/lmj1436140682/article/details/63262459" target="_blank" rel="noopener">HTTP 报文及作用</a>，参考大神佳作<a href="https://blog.csdn.net/wzx19840423/article/details/47811559" target="_blank" rel="noopener">HTTP报文详解</a></p>
</li>
</ul>
<p></p><h6>实体部分</h6><p></p>
<ul>
<li>实体的主体是HTTP报文的负荷,就是HTTP要传输的内容</li>
<li>HTTP报文可以承载很多类型的数字数据，图片、视频、HTML文档、软件应用程序、信用卡事务、电子邮件等</li>
<li>参考大神佳作<a href="https://blog.csdn.net/u012422829/article/details/51570652" target="_blank" rel="noopener">报文实体和编码</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/01/HTTP报文/" data-id="ck6x5spae0016kcwvhycu27hz" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络基础知识/">网络基础知识</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-scrapy基础了解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/29/scrapy基础了解/" class="article-date">
  <time datetime="2018-03-29T01:25:36.000Z" itemprop="datePublished">2018-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/29/scrapy基础了解/">scrapy基础了解</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>scrapy基础了解</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中</li>
<li>依赖包<ul>
<li>1.wheel      安装该文件后就可以安装.whl的依赖文件</li>
<li>2.lxml       解析页面 </li>
<li>3.PyOpenssl</li>
<li>4.Twisted</li>
<li>5.Pywin32，pypiwin32</li>
<li>6.Scrapy </li>
</ul>
</li>
<li>基本思路:<img src="../scrapy.jpg" alt="Scrapy基本思路"><ul>
<li>1.Scrapy Engine: 引擎，负责Spiders、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等等！</li>
<li>2.Scheduler(调度器): 它负责接受引擎发送过来的requests请求，并按照一定的方式进行整理排列，入队、并等待Scrapy Engine(引擎)来请求时，交给引擎</li>
<li>3.Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spiders来处理</li>
<li>4.Spiders：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)</li>
<li>5.Item Pipeline：它负责处理Spiders中获取到的Item，并进行处理，比如去重，持久化存储（存数据库，写入文件，总之就是保存数据用的）</li>
</ul>
</li>
<li>测试网站：<a href="http://quotes.toscrape.com/" target="_blank" rel="noopener">http://quotes.toscrape.com/</a></li>
</ul>
<p></p><h6>详解</h6><p></p>
<ul>
<li><p>1.进入要放置项目的目录，shift+右键的shell，输入命令：<code>scrapy startproject quotetutorial</code>，创建项目</p>
<ul>
<li>spiders    #这个目录放置爬虫</li>
<li>items.py   #这个文件定义我们需要获取的字段</li>
<li>pipelines.py    #这个文件用来定义数据存储</li>
<li>settings.py        #这个文件用来设置</li>
</ul>
</li>
<li><p>2.进入项目，<code>cd quotetutorial</code>,创建爬虫：<code>scrapy genspider quotes quotes.toscrape.com</code> </p>
</li>
<li><p>3.在spiders文件夹下的quotes中编写自己的爬虫</p>
<pre><code>import scrapy
from quotetutorial.items import QuoteItem
class QuotesSpider(scrapy.Spider):
    name = &apos;quotes&apos;
    allowed_domains = [&apos;quotes.toscrape.com&apos;]
    start_urls = [&apos;http://quotes.toscrape.com/&apos;]

    def parse(self, response):
        quotes=response.css(&apos;.quote&apos;)
        for quote in quotes:
            item=QuoteItem() #先声明一个对象，然后赋值
            text=quote.css(&apos;.text::text&apos;).extract_first()
            author=quote.css(&apos;.author::text&apos;).extract_first()
            tags=quote.css(&apos;.tags .tag::text&apos;).extract()
            item[&apos;text&apos;]=text
            item[&apos;author&apos;]=author
            item[&apos;tags&apos;]=tags
            yield item #做下一步的存储操作
        next=response.css(&apos;.pager .next a::attr(href)&apos;).extract_first()
        url=response.urljoin(next)
        yield scrapy.Request(url=url,callback=self.parse)
</code></pre></li>
<li><p>4.在items.py文件中定义一些字段，这些字段用来临时存储需要保存的数据。方便后面保存数据到其他地方，比如数据库或者本地文本之类的</p>
<pre><code>import scrapy
class QuoteItem(scrapy.Item):
    text=scrapy.Field()
    author=scrapy.Field()
    tags=scrapy.Field()
</code></pre></li>
<li><p>5.在Terminal中运行爬虫<code>scrapy crawl quotes</code>;运行并且保存爬取数据为json格式<code>scrapy crawl quotes -o quotes.json</code> </p>
</li>
<li><p>6.保存数据到Mongodb中</p>
<ul>
<li><p>6.1在pipelines.py编写连接</p>
<pre><code>from scrapy.exceptions import DropItem
import pymongo
class TextPipeline(object):
    def __init__(self):
        self.limit=50
    def process_item(self, item, spider):
        if item[&apos;text&apos;]:
            if len(item[&apos;text&apos;])&gt;self.limit:
                item[&apos;text&apos;]=item[&apos;text&apos;][0:self.limit].rstrip()+&apos;...&apos;
            return item
        else:
            return DropItem(&apos;Missing Text&apos;)   #如果text不存在，则抛出异常
class MongoPipeline(object):
    def __init__(self,mongo_uri,mongo_db):
        self.mongo_uri=mongo_uri
        self.mongo_db=mongo_db
    @classmethod
    def from_crawler(cls,crawler):
        return cls(
            mongo_uri=crawler.settings.get(&apos;MONGO_URI&apos;),
            mongo_db=crawler.settings.get(&apos;MONGO_DB&apos;)
        )
    def open_spider(self,spider):
        self.client=pymongo.MongoClient(self.mongo_uri)
        self.db=self.client[self.mongo_db]
    def process_item(self,item,spider):
        name=item.__class__.__name__
        self.db[name].insert(dict(item))
        return item
    def close_spider(self,spider):
        self.client.close()  
</code></pre></li>
<li><p>6.2在settings中设置</p>
<pre><code>MONGO_URI=&apos;localhost:27017&apos;
MONGO_DB=&apos;quotetutorial&apos;

ITEM_PIPELINES = {
   &apos;quotetutorial.pipelines.TextPipeline&apos;: 300,
   &apos;quotetutorial.pipelines.MongoPipeline&apos;: 1000,
}
</code></pre></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/29/scrapy基础了解/" data-id="ck6x5sphz005hkcwv6jz9s4pc" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫学习/">爬虫学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-网络配置、系统查看" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/28/网络配置、系统查看/" class="article-date">
  <time datetime="2018-03-28T15:00:41.000Z" itemprop="datePublished">2018-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/网络配置、系统查看/">网络配置、系统查看</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>网络配置、系统查看</h5><p></p>
<hr>
<hr>
<p></p><h6>网络配置</h6><p></p>
<ul>
<li>VMware的三种网络连接方式区别</li>
<li>桥接模式<ul>
<li>在局域网内，虚拟机和宿主机视为两台PC机；可以单独通过局域网网关或者路由访问外网</li>
<li>利用相同的网关网段配置，Bridged可用来配置集群</li>
</ul>
</li>
<li>NAT（网络地址转换）<ul>
<li>NAT方式使虚拟机接入外网方便，不需要进行其他配置，只需要物理主机可以上网即可</li>
<li>NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯</li>
<li>不能用NAT配置集群</li>
</ul>
</li>
<li>Host-Only（主机）<ul>
<li>这种模式下，所有局域网内所有虚拟机互通，但虚拟机无法访问外网，与外网完全隔离</li>
<li>此种模式同样可以配置集群，但是集群无法访问外网，比较适合公司内网</li>
</ul>
</li>
</ul>
<p></p><h6>linux系统ifconfig命令不显示IP地址或者只显示127.0.0.1</h6><p></p>
<ul>
<li>1.在Linux系统中输入命令:   vi  /etc/sysconfig/network-scripts/ifcfg-ens33</li>
<li>2.修改文件中的ONBOOT=no,将no改为yes</li>
<li>3.重启服务: service network restart</li>
</ul>
<p></p><h6>系统查看</h6><p></p>
<ul>
<li><p>查看进程</p>
<pre><code>ps -A 显示所有程序
ps -H 显示树状结构，表示程序间的相互关系
ps u 以用户为主的格式来显示程序状况
ps aux|less 查看所有运行中的进程
</code></pre></li>
<li><p>监控系统资源</p>
<pre><code>top 查看整个系统运行状况；该命令功能十分强大，但是它的缺点是会消耗很多系统资源
free -m 显示内存使用情况
</code></pre></li>
<li><p>查看硬盘占用</p>
<pre><code>df -h  检查linux服务器的文件系统的磁盘空间占用情况
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/28/网络配置、系统查看/" data-id="ck6x5spmz008hkcwvqyur8euw" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux学习/">Linux学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-vi-vim" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/28/vi-vim/" class="article-date">
  <time datetime="2018-03-28T14:55:30.000Z" itemprop="datePublished">2018-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/vi-vim/">vi/vim</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>vi/vim</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>vi是一款用来创建编辑文件的文本编辑软件</li>
<li>vi的三大模式：<ul>
<li>命令模式：用户刚刚启动 vi，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符</li>
<li>底线命令模式：在命令模式下按下:（英文冒号）就进入了底线命令模式，主要进行文件的保存和退出</li>
<li>编辑模式：在命令模式下按下i就进入了编辑模式</li>
</ul>
</li>
<li>模式之间的转化常用到Esc，Shift+：</li>
</ul>
<p></p><h6>命令模式</h6><p></p>
<ul>
<li><p>常用命令</p>
<pre><code>i 切换到编辑模式，以输入字符；在当前光标处插入
a 在当前光标处下一个字符插入
o 在当前光标处下一行插入新的一行
</code></pre></li>
</ul>
<p></p><h6>底线命令行模式</h6><p></p>
<ul>
<li><p>常用命令</p>
<pre><code>:q       #表示不保存退出
:q!         #强制退出
:w         #保存修改内容
:wq         #保存并退出
:set nu  #显示行号
:set nonu   #不显示行号
:r 文件名    #在编辑的数据中，读入另一个档案的数据，将文件内容加到游标所在行后面
:1,$s /word1/word2/g  #从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 
:n1,n2s/word1/word2/g #n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2
</code></pre></li>
</ul>
<p></p><h6>编辑模式</h6><p></p>
<ul>
<li><p>删除、复制、粘贴</p>
<pre><code>gg  移到这个文件的第一行
G   移到这个文件的最后一行
ngg 移到这个文件的第几行

yy     复制光标所在行
nyy 复制光标所在的向下n行

P  大写，粘贴在光标的上一行
p  小写，粘贴在光标的下一行

dd        删除光标所在一整行
ndd        删除光标所在向下n行

数字0    移到这一行的最前面
$         移到这一行的最后面

u        撤销上一次的操作
Ctrl+r    恢复撤销
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/28/vi-vim/" data-id="ck6x5spih005tkcwv2rn5j3c0" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux学习/">Linux学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-linux常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/28/linux常用命令/" class="article-date">
  <time datetime="2018-03-28T09:05:54.000Z" itemprop="datePublished">2018-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/linux常用命令/">linux常用命令</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>linux常用命令</h5><p></p>
<hr>
<hr>
<p></p><h6>常见的系统目录结构</h6><p></p>
<ul>
<li><p>根目录下</p>
<pre><code>[root@localhost ~]# ls /
bin   dev  ftp   lib    media  opt   root  sbin  sys  usr
boot  etc  home  lib64  mnt    proc  run   srv   tmp  var
</code></pre><ul>
<li>bin：Binary的缩写, 这个目录存放着最经常使用的命令</li>
<li>boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</li>
<li>dev：Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的</li>
<li>etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录</li>
<li>home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</li>
<li>lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库</li>
<li>media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</li>
<li>mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了</li>
<li>opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的</li>
<li>proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息</li>
<li>root：该目录为系统管理员，也称作超级权限者的用户主目录</li>
<li>tmp：这个目录是用来存放一些临时文件的</li>
<li>usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录</li>
<li>var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</li>
</ul>
</li>
</ul>
<p></p><h6>终端</h6><p></p>
<ul>
<li><p>用户</p>
<pre><code>新建用户：useradd &lt;name&gt;  系统自动在/home下创建与此用户同名的文件夹
         passwd &lt;name&gt;
删除用户：userdel &lt;name&gt;
切换用户：su &lt;name&gt;
退出当前用户：logout (普通用户)
             exit  （管理用户）
</code></pre></li>
<li><p>前缀</p>
<pre><code>[root@localhost ~]# 

1.root 表示登录的用户名
2.localhost 表示登录的主机，服务器地址
3.~ 表示当前用户的所在路径，即/root；主目录，当前用户的主目录
4.# 表示超管用户，$ 表示普通用户
</code></pre></li>
<li><p>开机关机<br>不管是重启系统还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中</p>
<pre><code>sync 将数据由内存同步到硬盘中
shutdown -h now 离开关机
shutdown -h +10 10分钟后关机
shutdown -h 10:10 系统会在今天的10:10关机
reboot 系统重启
halt 关闭系统
</code></pre></li>
</ul>
<p></p><h6>目录/文件命令</h6><p></p>
<ul>
<li><p>新建目录</p>
<pre><code>mkdir &lt;目录名&gt;                        创建单个目录
mkdir -p &lt;目录名1&gt;/&lt;目录名2&gt;/&lt;目录名3&gt; 创建多层目录
mkdir -m *** &lt;目录名&gt;                 创建目录时指定权限，三颗星代表rwx的数字码
</code></pre></li>
<li><p>新建文件</p>
<pre><code>touch 文件名
</code></pre></li>
<li><p>删除目录</p>
<pre><code>rmdir &lt;目录名&gt;        删除空的目录
rm -r &lt;目录名&gt;        递归删除整个目录树,非空
rm &lt;文件名或者目录名&gt;        删除文件
rm -i &lt;文件名或者目录名&gt;     互动模式，在删除前会询问是否动作
rm -f &lt;文件名&gt;        强制删除文件，没有提示
</code></pre></li>
<li><p>查看目录</p>
<pre><code>ls 表示查看当前目录下的文件或者文件夹
ls -a 表示查看当前目录下的所有内容，包括隐藏文件
ls -l 表示查看当前目录下内容的详细信息
ls -al 表示查看当前目录下所有内容的详细内容
</code></pre></li>
<li><p>切换目录</p>
<pre><code>cd [相对路径或绝对路径] .表示当前路径  ..表示上层路径
</code></pre></li>
<li><p>复制目录/文件</p>
<pre><code>cp 源文件 /目的地址
cp -i 源文件 /目的地址     若目标档已存在，在覆盖时会先询问动作的进行
</code></pre></li>
<li><p>剪切目录/文件</p>
<pre><code>mv 文件名/目录名 目的地
</code></pre></li>
<li><p>重命名</p>
<pre><code>mv 文件名/目录名 新的文件名/目录名
</code></pre></li>
</ul>
<p></p><h6>文件内容查看</h6><p></p>
<ul>
<li><p>cat、more、head</p>
<pre><code>cat 文件名      #正序查看，由第一行开始显示文件内容
cat -n 文件名   #连同空白行也会显示行号

tac 文件名      #倒序查看
tac -n 文件名   #连同空白行也会显示行号

more 文件名     #查看大文件，显示百分比；空白键代表向下翻页，Enter键表示向下翻行
less 文件夹     #查看大文件，不显示百分比；空白键代表向下翻页，[pgup][pgdn]代表向上向下翻页

head 文件名             #默认显示前10行
head -n 数字 文件名       #规定显示前几行

tail 文件名               #默认显示最后10行
tail -n 数字 文件名      #规定显示最后几行
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/28/linux常用命令/" data-id="ck6x5spg8004fkcwv3zzdcl41" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux学习/">Linux学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-session会话" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/28/session会话/" class="article-date">
  <time datetime="2018-03-28T09:01:57.000Z" itemprop="datePublished">2018-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/session会话/">session会话</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>session会话</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>在我们登录成功之后，我们需要把用户信息显示在页面上，并且在跳转到别的页面的时候，这个用户依然是已经登录的状态浏览器可以识别，这就需要session 会话作用域</li>
<li>django session的设计原理<ul>
<li>a、如果用户是第一次请求（就看客户端ie是否保存了sessionId的cookie）<br>创建session model <br>生成一个key sessionId 随机的一个字符串（uuid使id永远也不会重复）<br>保存到你session_engine指定位置<br>保存到cookie中，在客户的浏览器中</li>
<li>b、如果第二次以上的请求，客户端ie都会自动提交cookie到django中，django中利用你配置的SessionMiddleware中间件激活session利用cookie中的sessionID到session_engine指定位置读取session model，并设置到request的session属性上<br>正是因为这样才能在view里面通过request.session使用session</li>
<li>session只能储存json也就是字典类型的数据; session本身就是一个dict字段;session在存数据时数据必须支持序列化json</li>
</ul>
</li>
</ul>
<p></p><h6>步骤</h6><p></p>
<ul>
<li><p>1.installed_apps</p>
<pre><code>#settings.py
INSTALLED_APPS = [
    &apos;django.contrib.sessions&apos;,
]
</code></pre></li>
<li><p>2.中间件（帮我们启用session）</p>
<pre><code>#settings.py
MIDDLEWARE = [
   &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;,
]
</code></pre></li>
<li><p>3.设置存储形式（储存在设置数据库中）</p>
<pre><code>makemigrations sessions
migrate
</code></pre></li>
<li><p>4.引用 request.session</p>
<pre><code>#views.py
def login(request):
    if request.method==&quot;GET&quot;:
        return render(request,&apos;login.html&apos;,{})
    else:
        username=request.POST.get(&apos;username&apos;)
        pwd=request.POST.get(&apos;pwd&apos;)
        BlogUserSet = BlogUser.objects.filter(username=username,pwd=pwd)
        if len(BlogUserSet)==1:
            session=request.session
            session[&apos;user&apos;]={&apos;username&apos;:BlogUserSet.first().username}
            return redirect(reverse(&apos;user:welcome&apos;))
            #return redirect(reverse(&apos;user:welcome&apos;,args=[BlogUserSet.first().id]))
        else:
            return render(request,&apos;login.html&apos;,{&apos;username&apos;:username,&apos;error&apos;:&apos;用户名或者密码错误！&apos;})
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/28/session会话/" data-id="ck6x5spi8005nkcwvykb2d1nu" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django学习/">Django学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-转发与重定向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/27/转发与重定向/" class="article-date">
  <time datetime="2018-03-27T03:50:35.000Z" itemprop="datePublished">2018-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/27/转发与重定向/">转发与重定向</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>转发与重定向</h5><p></p>
<hr>
<hr>
<p></p><h6>重定向</h6><p></p>
<ul>
<li>数据库虽然已经添加了数据，但如果继续刷新浏览器数据库会保存重复的数据,这就需要重定向</li>
<li>转发：一次请求和响应，请求的地址没有发生变化，请求的数据被服务器内部的资源共享，如果此时刷新页面就会出现重做现象（服务器响应给客户的是转发）</li>
<li>重定向：一次以上的请求和响应，请求地址发生一次以上的变化。如果此时刷新页面不会出现重做现象（指向虚拟的网址页面）</li>
<li><p>需要在views.py里面导入redirect和reverse模块，然后需要在我们刷新的时候跳转到另一个页面,代码如下：</p>
<pre><code>#在bloguser/urls.py添加路径
app_name=&apos;user&apos;
urlpatterns = [
    path(&apos;register&apos;, register),
    path(&apos;welcome/&lt;int:id&gt;&apos;, welcome,name=&apos;welcome&apos;),
]

#在bloguser/views.py
def register(request):
    if request.method==&apos;GET&apos;:
        return render(request,&apos;register.html&apos;)
    elif request.method==&apos;POST&apos;:
        bloguser=BlogUser()
        bloguser.username=request.POST.get(&apos;username&apos;)
        bloguser.pwd=request.POST.get(&apos;pwd&apos;)
        bloguser.save()
        return redirect(reverse(&apos;user:welcome&apos;,args=[bloguser.id]))   #user,虚拟的命名空间，welcome，执行的函数,
def welcome(request,id):
    bloguser=BlogUser.objects.get(pk=id)
    return render(request, &apos;welcome.html&apos;, {&apos;bloguser&apos;: bloguser})

#在pyblog/urls.py下
urlpatterns = [
    path(&apos;admin/&apos;, admin.site.urls),
    path(&apos;bloguser/&apos;,include(&apos;bloguser.urls&apos;)),
    path(&apos;user/&apos;,include(&apos;bloguser.urls&apos;,namespace=&apos;user&apos;)),
]
</code></pre></li>
</ul>
<p></p><h6>重名</h6><p></p>
<ul>
<li>如果使用<code>unique=True</code>，我们必须点击提交才会告诉我们用户名重复，应该在我们输入密码的时候就告诉我们用户名重复</li>
<li><p>这时候我们需要使用ajax(ajax: jquery 是一种静态资源),不需要我们提交，当我们输入密码的时候就可以告诉我们用户名已重复</p>
<ul>
<li>1.在pyblog里面创建一个static的文件夹，接着创建js的文件夹，把jquery-3.3.1放进去</li>
<li><p>2.接着需要在setings.py里面添加static文件</p>
<pre><code>STATIC_URL = &apos;/static/&apos;
STATICFILES_DIRS=[
    os.path.join(BASE_DIR,  &apos;static&apos;)
]
</code></pre></li>
<li><p>3.在register.html中加上javascript</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/static/js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;
&lt;script &gt;
    $(function(){
        $(&apos;input[name=&quot;username&quot;]&apos;).blur(function(){
            uname=$(&apos;input[name=&quot;username&quot;]&apos;).val()
            CSRF=$(&quot;input[name=&apos;csrfmiddlewaretoken&apos;]&quot;).val()
            $.ajax({
                url:&apos;/bloguser/getUser&apos;,
                data:{&apos;uname&apos;:uname,&apos;csrfmiddlewaretoken&apos;:CSRF},
                type:&apos;POST&apos;,
                success:function(dat){
                    if(dat==&apos;True&apos;){
                        $(&apos;span&apos;).html(&apos;用户名已经存在！&apos;)
                    }
                    else{
                        $(&apos;span&apos;).html(&apos;用户名可以使用！&apos;)
                    }
                }
            })
        })
    })
&lt;/script&gt;
</code></pre></li>
<li><p>4.在views.py定义一个getUser(),同时需要导入HttpResponse模块，用来判断用户名有没有重复</p>
<pre><code>def getUser(request):
    uname=request.POST.get(&apos;uname&apos;)
    BlogUserSet=BlogUser.objects.filter(username=uname)
    if len(BlogUserSet)==1:
        return HttpResponse(&apos;True&apos;)
    else:
        return HttpResponse(&apos;False&apos;)
</code></pre></li>
<li><p>5.然后在bloguser\urls.py配置一下路径</p>
<pre><code>app_name=&apos;user&apos;
urlpatterns = [
    path(&apos;register&apos;, register),
    path(&apos;getUser&apos;, getUser),
    path(&apos;welcome/&lt;int:id&gt;&apos;, welcome,name=&apos;welcome&apos;),
]
</code></pre></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/27/转发与重定向/" data-id="ck6x5spnn008tkcwvl2ujy822" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django学习/">Django学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-pyspider框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/24/pyspider框架/" class="article-date">
  <time datetime="2018-03-24T10:41:19.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/24/pyspider框架/">pyspider框架</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>pyspider框架</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>pyspider 是一个用python实现的功能强大的网络爬虫系统，能在浏览器界面上进行脚本的编写，功能的调度和爬取结果的实时查看，后端使用常用的数据库进行爬取结果的存储，还能定时设置任务与任务优先级等</li>
<li>PhantomJS 是一个基于 WebKit 的服务器端 JavaScript API。它全面支持web而不需浏览器支持，其快速、原生支持各种Web标准：DOM 处理、CSS 选择器、JSON、Canvas 和 SVG。 PhantomJS 可以用于页面自动化、网络监测、网页截屏以及无界面测试等</li>
<li>安装完pyspider、phantomJS后，在命令行输入<code>pyspider all</code>启动pyspider所有服务组件…然后浏览器访问 <a href="http://localhost:5000，如果正常出现" target="_blank" rel="noopener">http://localhost:5000，如果正常出现</a> PySpider 的页面，那证明一切OK</li>
<li>pyspider的架构主要分为 scheduler（调度器）, fetcher（抓取器）, processor（脚本执行）,以及一个监控组件，当启动服务组件的时候，这些程序均开始运行了…<ul>
<li>1.各个组件间使用消息队列连接，除了scheduler是单点的，fetcher 和 processor 都是可以多实例分布式部署的。 scheduler 负责整体的调度控制</li>
<li>2.任务由 scheduler 发起调度，fetcher 抓取网页内容， processor 执行预先编写的python脚本，输出结果或产生新的提链任务（发往 scheduler），形成闭环</li>
<li>3.每个脚本可以灵活使用各种python库对页面进行解析，使用框架API控制下一步抓取动作，通过设置回调控制解析动作</li>
</ul>
</li>
</ul>
<p></p><h6>页面内容解析</h6><p></p>
<ul>
<li>拿www.reeoo.com这个网页，爬取上面的数据</li>
<li>创建新项目页面：<ul>
<li>Project Name：任务的名字</li>
<li>Start URL(s)：爬取任务开始的地址</li>
</ul>
</li>
<li><p>创建后的页面</p>
<pre><code>from pyspider.libs.base_handler import *
class Handler(BaseHandler):
    crawl_config = {
    }

    @every(minutes=24 * 60)
    #@every(minutes=24 * 60) 通知 scheduler（框架的模块） 每天运行一次
    def on_start(self):
    #on_start(self) 程序的入口，当点击左侧绿色区域右上角的 run 按钮时首先会调用这个函数
        self.crawl(&apos;https://reeoo.com/&apos;, callback=self.index_page)
    #self.crawl(url, callback) pyspider库主要的API，用于创建一个爬取任务，url 为目标地址，这里为我们刚刚创建任务指定的起始地址，callback 为抓取到数据后的回调函数

    @config(age=10 * 24 * 60 * 60)
    #@config(age=10 * 24 * 60 * 60) 设置任务的有效期限，在这个期限内目标爬取的网页被认为不会进行修改
    def index_page(self, response):
    #index_page(self, response) 参数为 Response 对象，response.doc 为 pyquery 对象，主要用来方便地抓取返回的html文档中对应标签的数据
        for each in response.doc(&apos;a[href^=&quot;http&quot;]&apos;).items():
            self.crawl(each.attr.href, callback=self.detail_page)

    @config(priority=2)
    #@config(priority=2) 设定任务优先级
    def detail_page(self, response):
    #detail_page(self, response) 返回一个 dict 对象作为结果，结果会自动保存到默认的 resultdb 中，也可以通过重载方法来将结果数据存储到指定的数据库
        return {
            &quot;url&quot;: response.url,
            &quot;title&quot;: response.doc(&apos;title&apos;).text(),
        }
</code></pre></li>
<li><p>运行代码后时出现 HTTP 599: SSL certificate problem: unable to get local issuer certificate错误时：<br><br>使用 self.crawl(url, callback=self.index_page, validate_cert=False)</p>
</li>
<li>运行<br>1.点击左边绿色区域右上角的 run 按钮，运行之后页面下册的 follows 按钮出现红色角标<br>2.选中 follows 按钮，看到 index_page 行，点击行右侧的运行按钮<br>3.运行完成后显示 www.reeoo.com 页面上所有的url<br>4.此时任意选择一个结果运行，此时调用的是 detail_page 方法，返回结果为json格式的数据，这里我们保存的是网页的 title 和 url，见左侧黑色的区域<br>5.回到主页面，此时看到任务列表显示刚刚创建的任务，设置 status 为 running，然后点击 Run 按钮执行<br>6.执行过程中可以看到整个过程的打印输出<br>7.执行完成后，点击 Results 按钮，进入到爬取结果的页面<br>8.右上方的按钮选择将结果数据保存成对应的格式，例如：JSON格式的数据</li>
</ul>
<p></p><h6>查找文件路径</h6><p></p>
<ul>
<li>由于配置了windows的环境变量，所以习惯性的打开CMD后就直接敲命令行执行 pyspider语句，但找不到pyspider存储的数据在哪里</li>
<li>后来才发现，pyspider命令行执行的时候，数据库data文件会自动在当前目录生成，即在<code>C:\Users\DELL&gt;</code>下，<code>C:\Users\DELL\data</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/24/pyspider框架/" data-id="ck6x5sph4004xkcwvo58cj1xx" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫学习/">爬虫学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-selenium模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/23/selenium模块/" class="article-date">
  <time datetime="2018-03-23T15:15:47.000Z" itemprop="datePublished">2018-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/23/selenium模块/">selenium模块</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>selenium模块</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>selenium 是一套完整的web应用程序测试系统，Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上，爬虫中主要用来解决JavaScript渲染问题</li>
<li>Selenium.Webdriver支持的浏览器中，比较重要的PhantomJS,PhantomJS是一个基于WebKit的服务端JavaScript API,支持Web而不需要浏览器支持，其快速、原生支持各种Web标准：Dom处理，CSS选择器，JSON等等。PhantomJS可用于页面自动化、网络监测、网页截屏，以及无界面测试</li>
</ul>
<p></p><h6>查找元素</h6><p></p>
<ul>
<li><p>单个元素和多个元素的查找，用法基本一致</p>
<pre><code>from selenium import webdriver
from selenium.webdriver.common.by import By
from time import sleep

browser=webdriver.Chrome()
browser.get(&apos;http://www.baidu.com&apos;)  #声明浏览器对象
#print(browser.page_source)       #打印百度首页的源代码
input=browser.find_element(By.ID,&apos;kw&apos;)
input.clear()
input.send_keys(&apos;selenium&apos;)
button=browser.find_element(By.CSS_SELECTOR,&apos;#su&apos;)
button.click()
sleep(3)
browser.close()
</code></pre></li>
<li><p>这里列举一下常用的查找元素方法：</p>
<pre><code>find_element_by_name
find_element_by_id
find_element_by_xpath
find_element_by_link_text
find_element_by_partial_link_text
find_element_by_tag_name
find_element_by_class_name
find_element_by_css_selector
</code></pre></li>
</ul>
<p></p><h6>执行JavaScript</h6><p></p>
<ul>
<li><p>这是一个非常有用的方法，这里就可以直接调用js方法来实现一些操作，下面的例子是通过登录知乎然后通过js翻到页面底部，并弹框提示</p>
<pre><code>from selenium import webdriver

browser=webdriver.Chrome()
browser.get(&apos;http://www.zhihu.com/explore&apos;)  #声明浏览器对象
browser.execute_script(&apos;window.scrollTo(0,document.body.scrollHeight)&apos;)
browser.execute_script(&apos;alert(&quot;Hello World!&quot;)&apos;)
</code></pre></li>
</ul>
<p></p><h6>01</h6><p></p>
<ul>
<li><p>获取属性值、文本值</p>
<pre><code>from selenium import webdriver
from selenium.webdriver.common.by import By

browser=webdriver.Chrome()
browser.get(&apos;https://www.zhihu.com/explore&apos;)
logo=browser.find_element(By.ID,&apos;zh-top-link-logo&apos;)
print(logo.get_attribute(&apos;class&apos;))    #获取元素的属性值
print(logo.text)                      #获取文本值
print(logo.id)
print(logo.location)                  #获取位置
print(logo.tag_name)                  #获取标签名
print(logo.size)
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/23/selenium模块/" data-id="ck6x5spi5005lkcwvawimu6op" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/爬虫学习/">爬虫学习</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/9/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django学习/">Django学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA项目部署/">JAVA项目部署</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux学习/">Linux学习</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL学习/">MySQL学习</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx学习/">Nginx学习</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL学习/">NoSQL学习</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python学习/">Python学习</a><span class="tag-list-count">27</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web前端/">Web前端</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全测试/">安全测试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫学习/">爬虫学习</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络基础知识/">网络基础知识</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化测试/">自动化测试</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工具/">软件工具</a><span class="tag-list-count">6</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django学习/" style="font-size: 11.82px;">Django学习</a> <a href="/tags/JAVA项目部署/" style="font-size: 17.27px;">JAVA项目部署</a> <a href="/tags/Linux学习/" style="font-size: 19.09px;">Linux学习</a> <a href="/tags/MySQL学习/" style="font-size: 18.18px;">MySQL学习</a> <a href="/tags/Nginx学习/" style="font-size: 10.91px;">Nginx学习</a> <a href="/tags/NoSQL学习/" style="font-size: 16.36px;">NoSQL学习</a> <a href="/tags/Python学习/" style="font-size: 20px;">Python学习</a> <a href="/tags/Web前端/" style="font-size: 14.55px;">Web前端</a> <a href="/tags/大数据/" style="font-size: 12.73px;">大数据</a> <a href="/tags/安全测试/" style="font-size: 10px;">安全测试</a> <a href="/tags/性能测试/" style="font-size: 14.55px;">性能测试</a> <a href="/tags/爬虫学习/" style="font-size: 15.45px;">爬虫学习</a> <a href="/tags/网络基础知识/" style="font-size: 10px;">网络基础知识</a> <a href="/tags/自动化测试/" style="font-size: 13.64px;">自动化测试</a> <a href="/tags/软件工具/" style="font-size: 12.73px;">软件工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/22/centos7-4鲁班部署/">centos7.4鲁班部署</a>
          </li>
        
          <li>
            <a href="/2020/02/14/Centos7查看、新增和删除端口/">Centos7查看、新增和删除端口</a>
          </li>
        
          <li>
            <a href="/2020/02/07/centos7查看、打开和关闭防火墙/">centos7查看、打开和关闭防火墙</a>
          </li>
        
          <li>
            <a href="/2020/02/07/使用netstat、ss、lsof命令查询服务端口/">使用netstat、ss、lsof命令查询服务端口</a>
          </li>
        
          <li>
            <a href="/2019/12/22/已经安装nginx情况下添加http-ssl-module模块/">已经安装nginx情况下添加http_ssl_module模块</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
       Email:<a>liuyongqian51@163.com</a><br />
          QQ:<a>272501447</a><br />
	  Github:<a></a>
    </div>
  </div>

  
  

</aside>


        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 刘永前<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>

</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>