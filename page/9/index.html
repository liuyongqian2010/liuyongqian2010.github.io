<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>LiuYongQian</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="永远相信美好的事情将要发生！">
<meta property="og:type" content="website">
<meta property="og:title" content="LiuYongQian">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="LiuYongQian">
<meta property="og:description" content="永远相信美好的事情将要发生！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiuYongQian">
<meta name="twitter:description" content="永远相信美好的事情将要发生！">
  
    <link rel="alternate" href="/atom.xml" title="LiuYongQian" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LiuYongQian</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">永远相信美好的事情将要发生！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Python之IO操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/11/Python之IO操作/" class="article-date">
  <time datetime="2018-03-11T00:28:56.000Z" itemprop="datePublished">2018-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/11/Python之IO操作/">Python之IO操作</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>Python之IO操作</h5><p></p>
<hr>
<hr>
<h6>简介</h6>

<ul>
<li>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的</li>
<li>读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）</li>
</ul>
<h6>常用mode</h6>

<pre><code>r:以读方式打开文件（默认）
r+:打开一个文件用于读写,文件指针将会放在文件的开头
rb+:以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头
w:以写方式打开文件，可向文件中写入信息。如果文件存在，会清空文件，再写入新内容
w+:打开一个文件用于读写,如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件
wb+:以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件
a:以追加模式打开文件，如果文件不存在就先创建
a+:打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写
ab+:以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写
</code></pre><p></p><h6>read()</h6><p></p>
<ul>
<li><p>为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回</p>
<pre><code>f=open(r&apos;E:\test1.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;)
#以读的模式打开一个文件对象，使用内置的open()函数，传入文件名和标示符
a=f.read()
#调用read()方法可一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示
print(a)
f.close()
#调用close()方法关闭文件。文件使用完毕后须关闭，因为文件对象会占用操作系统的资源，且操作系统同一时间能打开的文件数量有限
#由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以为了保证无论是否出错都能正确地关闭文件,可使用with语句来自动帮我们调用close()方法
#上述写法可用下边写法替换
with open(r&apos;E:\test1.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;) as f:
    print(f.read())
</code></pre></li>
</ul>
<p></p><h6>readline()、readlines()</h6><p></p>
<ul>
<li>f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行</li>
<li><p>f.readlines() 将返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割</p>
<pre><code>with open(r&apos;E:\test1.txt&apos;,&apos;r&apos;,encoding=&apos;gbk&apos;) as f:
    a=f.readlines()
    print(a)
</code></pre></li>
</ul>
<p></p><h6>tell()</h6><p></p>
<ul>
<li>f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数</li>
</ul>
<p></p><h6>seek()</h6><p></p>
<ul>
<li>如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数<ul>
<li>Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。 如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。例如：<ul>
<li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符</li>
<li>seek(x,1) ： 表示从当前位置往后移动x个字符</li>
<li>seek(-x,2)： 表示从文件的结尾往前移动x个字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><h6>write()</h6><p></p>
<ul>
<li><p>f.write(string) 将 string 写入到文件中, 然后返回写入的字符数</p>
<pre><code>with open(r&apos;E:\test2.txt&apos;,&apos;w+&apos;) as f:
    a=f.write(&apos;追加内容&apos;)
    print(a)          #result:4
    f.seek(0,0)       #将光标移到文件首
    b=f.read()        #读取文件内容
    print(b)
</code></pre></li>
</ul>
<p></p><h6>file-like Object</h6><p></p>
<ul>
<li>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。StringIO就是在内存中创建的file-like Object，常用作临时缓冲</li>
<li><p>二进制文件</p>
<ul>
<li><p>前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用’rb’模式打开文件即可</p>
<pre><code>f = open(&apos;E:\test.jpg&apos;, &apos;rb&apos;)
f.read()
f.close()
</code></pre></li>
</ul>
</li>
</ul>
<p><em>小白参考大神佳作<a href="https://www.cnblogs.com/guqing/p/6084009.html" target="_blank" rel="noopener">Python—-文件的IO操作</a></em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/11/Python之IO操作/" data-id="cjtyg84a7002b4gwvctufff6y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python学习/">Python学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-XSS注入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/XSS注入/" class="article-date">
  <time datetime="2018-03-10T15:44:11.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/XSS注入/">XSS注入</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>XSS注入</h5><p></p>
<hr>
<hr>
<p></p><h6>概念</h6><p></p>
<ul>
<li>跨站脚本攻击(Cross Site Script为了区别于CSS简称为XSS)指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的</li>
<li>例子，某个论坛或者页面上有个广告，网址是zhengpin.taobao.com，你点击进去，你看是购物网站，又是淘宝的，你就进去购买了，其实呢，他会redirect到另一个攻击者自己的网站，你在购买的时候，使用的是攻击者的接口进行付款，很可能就会被盗取个人信息及财产等</li>
</ul>
<p></p><h6>寻找跨站漏洞</h6><p></p>
<ul>
<li>如果有代码的话，我们主要看代码里对用户输入的地方和变量有没有做长度和对”&lt;”,”&gt;”,”;”,”’”等字符是否做过滤</li>
<li>还有要注意的是对于标签的闭合，像测试QQ群跨站漏洞的时候，你在标题处输入，这样就可以弹出一个test的框</li>
</ul>
<p></p><h6>XSS漏洞的后果</h6><p></p>
<ul>
<li>XSS漏洞可能造成的后果包括窃取用户会话，窃取敏感信息，重写Web页面，重定向用户到钓鱼网站等，尤为严重的是，XSS漏洞可能使得攻击者能够安装XSS代理，从而攻击者能够观察到该网站上所有用户的行为，并能操控用户访问其他的恶意网站</li>
</ul>
<p></p><h6>XSS漏洞的常见解决措施</h6><p></p>
<ul>
<li>第一种就是消除漏洞，简而言之就是在输出页面上不提供任何用户的输入信息</li>
<li>另外一种就是想办法来抵御这种漏洞，可以采用对所有用户的输入编码后再输出（可以用OWASP的ESAPI），也可以对所有用户输入进行“白名单”验证，另外，OWASP还提供了AntiSamy对HTML页面做优化以消除这个漏洞</li>
</ul>
<p></p><h6>XSS的分类及测试方法</h6><p></p>
<ul>
<li>Stored XSS，即存储式跨站攻击<ul>
<li>存储式跨站攻击简单来说就是攻击者提交给网站的数据会提交并永久保存到服务器的数据库或者是文件系统等其他地方，之后不做任何编码操作就会显示在web页面上。这是最厉害的攻击方式<ul>
<li>例如1:在一个网站的一些留言板或者新闻等可以输入的地方，输入一下代码<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，因为这个是留言板上或者评论等的内容，会被读取并且存储到服务器上，如果不作任何处理，当其他用户访问这个网页的时候，就会弹出一个关于cookie的警告信息</li>
<li>在评论的时候输入<code>&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;you are a foolish person&quot;)&lt;/script&gt;</code>，如果不进行处理，这个信息会被当做正常的留言存储到服务器，那个接下来每个访问这个页面的用户都会收到you are a foolish person的alert信息，会造成很大的影响。（可用于窃取密码，用户信息等）</li>
</ul>
</li>
<li>Reflected XSS，即反射跨站脚本攻击,这是最常见的攻击方式<ul>
<li>所谓反射，就是等着服务器所给的返回。我们在进行测试时依据的就是在自己页面上的简单注入。在web客户端提交了数据后，服务端马上给这个请求生成返回结果页，如果结果中包含了未验证的客户端输入数据，那就表示会允许客户端脚本直接注入到页面里，也就出现了这样一个漏洞</li>
<li>简单举个例子，在搜索引擎里边，我们如果搜索了一个包含html代码的字符串，如果返回的字符串仍然没被编码，那么搜索的内容就不是整个html代码了，而是只想过这个html代码，那就是存在XSS漏洞了</li>
</ul>
</li>
<li>Dom-Base XSS，即基于DOM的XSS攻击<ul>
<li>它是修改页面DOM节点数据信息而形成的XSS跨站脚本攻击，该漏洞多见于客户端脚本，意思就是如果一个js访问需要参数的url，并且需要把信息作用于自己当前的页面，信息又未被编码，就会出现该漏洞</li>
<li>例如：好多网站在网址后边带个参数（？XXX的），当看到这种情况时候，我们可以在参数后边加个，如果加了这个参数之后，这段script代码不被编码就输出，那就证明它具有这么一个漏洞</li>
<li>例如：某网站的url中含有？，我们输入<a href="http://application.com/xxx.jsp?，如果这个脚本执行了，那么我们就说这是一个XSS漏洞" target="_blank" rel="noopener">http://application.com/xxx.jsp?，如果这个脚本执行了，那么我们就说这是一个XSS漏洞</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><h6>完善的输入检查是预防XSS的重要措施</h6><p></p>
<ul>
<li><p>防范反射型XSS和存储型XSS</p>
<ul>
<li>输入检查在大多数的时候都是对可信字符的检查或输入数据格式的检查，如用户输入的注册账号信息中只允许包括字母、数字、下划线和汉字等，对于输入的一切非白名单内的字符均认为是非法输入。数据格式如输入的IP地址、电话号码、邮件地址、日期等数据都具有一定的格式规范，只有符合数据规范的输入信息才允许通过检查</li>
<li>输出检查主要是针对数据展示过程中，应该对数据信息进行HTML编码处理，将可能存在导致XSS跨站脚本攻击的恶意字符进行编码，在不影响正常数据显示的前提条件下，过滤恶意字符</li>
<li><p>常见的可能造成XSS跨站脚本攻击的字符及其HTML编码如下：</p>
<pre><code>“ &amp;quot;
‘ &amp;apos;
&amp; &amp;amp;
&lt; &amp;lt;
&gt;  &amp;gt;
</code></pre></li>
</ul>
</li>
<li><p>防范基于DOM的XSS</p>
<ul>
<li>从基于DOM的XSS的定义及其触发方式我们发现，当基于DOM的XSS跨站脚本攻击发生时，恶意数据的格式与传统的XSS跨站脚本攻击数据格式有一定的差异，甚至可以在不经过服务器端的处理和相应的情况下，直接对客户端实施攻击行为，因此上述我们应用于防范反射型XSS和存储型XSS的方法并不适用于防范基于DOM的XSS跨站脚本攻击</li>
<li><p>针对基于DOM的XSS防范的输入检查方法，我们发现在客户端部署相应的安全检测代码的过滤效果要比在服务器端检测的效果更加明显。例如，我们可以通过如下客户端检测代码来保证用户输入的数据只包含字母、数字和空格，代码如下：</p>
<pre><code>&lt;script&gt;
    var str = document.URL;
    str = str.substring(str.indexOf(&quot;username=&quot;)+9, str.length);
    str = unescape(str);
    var regex=/^([A-Za-z0-9+\s])*$/;
    if (regex.test(str))
    document.write(str);
&lt;/script&gt;
</code></pre></li>
<li><p>同样，我们也可以通过在服务端实现类似上述数据检查的功能，如在服务器端检测URL参数是否为预定的参数username,并对username参数的内容进行检测，确认数据内容是否为只包含数字、字母和空格符，实现服务端的数据过滤。但是，由于客户端数据的可控性，这种服务端检测的效果要明显弱于客户端检测</p>
</li>
<li><p>基于DOM的XSS输出检查与反射型XSS漏洞输出检查的方法相似，在将用户可控的DOM数据内容插入到文档之前，Web应用程序应对提交的数据进行HTML编码处理，将用户提交的数据中可能存在的各种危险字符和表达式进行过滤以安全的方式插入到文档中进行展现，如可以通过如下函数实现在客户端javascript中执行HTML编码处理</p>
<pre><code>function jsEncode(str){
    var d = document.createElement(&apos;div&apos;);
    d.appendChild(document.createTextNode(str));
    return d.innerHTML;
}
</code></pre></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/XSS注入/" data-id="cjtyg84bc00304gwva5uvlldu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全测试/">安全测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-SQL注入" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/SQL注入/" class="article-date">
  <time datetime="2018-03-10T14:12:52.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/SQL注入/">SQL注入</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>SQL注入</h5><p></p>
<hr>
<hr>
<p></p><h6>概念</h6><p></p>
<ul>
<li>攻击者之所以可以利用自己输入的数据来达到攻击网站的目的，原因就在于SQL语言作为一种解释型语言，它的数据其实是由程序员编写的代码和用户提交的数据共同组成的。正是这个原因，攻击者可以构造对自己有利的数据，利用网站的一些SQL漏洞来达到恶意的目的</li>
<li>SQL注入，就是指攻击者将恶意的字符串或者语句等信息作为参数输入，服务器在验证这个字段的时候，读取攻击者输入的数据，将其作为正常的值参与SQL语句的查询，试想，如果攻击者输入了一个字符串，在SQL语句执行之后，可以导致删除表等操作，对于一个应用来说，影响是很大的</li>
<li>通过网页的输入项来注入SQL查询或命令是一种技巧。许多网页会从用户那里获取参数，并构建SQL查询来访问数据库。以用户登录为例，页面收集用户名和密码然后构建SQL去查询数据库，来校验用户名和密码的有效性。</li>
</ul>
<p></p><h6>简单实例</h6><p></p>
<ul>
<li>某网站的登录功能，用户登录页面需要填写用户名和密码，假设如果其中一个用户名和密码是admin和123456，当用户在相应的表单中输入正确的用户名和密码之后，此应用的相应函数执行一定的验证（验证用户名和密码是否匹配），服务器执行SQL语句（表名是user）：<code>select * from user where username=’username’ and pwd=’password’</code>，逻辑是如果这个查询语句返回结果不为0，则认为是验证通过，即可以登录成功的用户</li>
<li>如果某用户输入admin和123456，即执行语句：select * from user where username=’admin’ and pwd=’123456’,执行结果不为0，所以用户登录成功</li>
<li>如果一个用户输入test’ or 1=’1和111111，即执行语句：select * from user where username=’test’ or 1=’1’ and pwd=’111111’，因为此查询语句中1=’1’的结果为1，or 1=’1’使查询条件始终返回1，因此此语句的查询结果不为0，这样，此用户没有使用正确的用户名和密码也可以登录成功，这就是SQL注入的一个简单实例</li>
</ul>
<p></p><h6>SQL注入一般会出现在哪些地方</h6><p></p>
<ul>
<li>含有输入数据表单的页面（登录界面、查询界面、反馈界面等），即使是hidden的表单也有可能存在这个问题</li>
<li>含有用户信息、ID等的URL（类似于<code>http://XXX/index.asp?ID=155</code>），可以操作ID后的参数数据</li>
</ul>
<p></p><h6>SQL注入的防范措施</h6><p></p>
<ul>
<li>从开发者的角度来说，防范措施如下<ul>
<li>转义敏感字符及字符串<br>SQL的敏感字符包括： “exec”, “xp<em>”, “sp</em>”, “declare”, “cmd”, “Union”, “+”, “//”,              ”..”, “;”, “’”, “–”, “%”, “0x”, “&gt;&lt;=!-*/()|” ,和空格</li>
<li>屏蔽出错信息：阻止攻击者知道攻击的结果</li>
<li>在服务端正式处理之前提交数据的合法性(合法性检查主要包括三 项:数据类型,数据长度,敏感字符的校验)进行检查等。最根本的解决手段,在确认客 户端的输入合法之前,服务端拒绝进行关键性的处理操作</li>
</ul>
</li>
<li>从测试人员的角度来说，防范措施是<ul>
<li>在程序开发前(即需求阶段),我们就应该有意识的将安全性检查应用到需求测试中,例如对一个表单需求进行检查时,我们一般检验以下几项安全性问题:需求中应说明表单中某一field的类型,长度,以及取值范围(主要作用就是禁止输入敏感字符)；需求中应说明如果超出表单规定的类型,长度,以及取值范围的,应用程序应给出不包含任何代码或数据库信息的错误提示等</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/SQL注入/" data-id="cjtyg84aw002q4gwvmdfkpobt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全测试/">安全测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-基本安全测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/基本安全测试/" class="article-date">
  <time datetime="2018-03-10T08:10:50.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/基本安全测试/">基本安全测试</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>基本安全测试</h5><p></p>
<hr>
<hr>
<p></p><h6>用户权限测试</h6><p></p>
<ul>
<li>用户权限控制<ul>
<li>用户权限控制主要是对一些有权限控制的功能进行验证</li>
<li>用户A才能进行的操作，B是否能够进行操作</li>
<li>只能有A条件的用户才能查看的页面，是否B能够查看（可直接敲URL访问）</li>
</ul>
</li>
<li>页面权限控制<ul>
<li>必须有登陆权限的页面，是否能够在不登陆情况下进行访问</li>
<li>必须经过A——B——C的页面，是否能够直接由A——C？</li>
</ul>
</li>
</ul>
<p></p><h6>URL安全测试</h6><p></p>
<ul>
<li>适用范围： URL中含有参数，也就是通过GET方式传递的HTTP请求</li>
<li>什么叫GET方式<ul>
<li>GET方式在客户端通过URL提交数据，数据在URL中可以看到</li>
<li>POST方式，数据放置在HTML HEADER内提交，数据在URL中看不到</li>
<li>GET只能传输比较少的数据，安全性较低，POST传输数据较多，安全性也比GET高</li>
</ul>
</li>
<li><p>测试关注点</p>
<ul>
<li>URL 参数检查<ul>
<li>对URL中参数信息检查是否正确，如：URL中的订单号、金额允许显示出来的话，需要验证其是否正确</li>
<li>对于一些重要的参数信息，不应该在URL中显示出来，如：用户登陆时登录名、密码是否被显示出来了</li>
</ul>
</li>
<li>URL参数值篡改<ul>
<li>修改URL中的数据，看程序是否能识别，对于URL中包含金额参数的，修改金额看是否能够提交成功（可能导致用户把2元金额改成1元金额能提交），还有修改订单号等重要信息看是否会报错</li>
</ul>
</li>
<li><p>URL中参数修改进行XSS注入</p>
<ul>
<li><p>XSS的全称是Cross Site Script（跨站点脚本），XSS的原理很简单，即进行脚本注入，URL执行时即把此脚本进行了执行，一般都是JavaScript脚本</p>
<pre><code>如“http://www.cnblogs.com/javame/index.asp?IDClass=2&amp;ClassName=abc”

改成“http://www.cnblogs.com/javame/index.asp?IDClass=2&amp;ClassName=abc&lt;script&gt;alert(&quot;hello&quot;);&lt;/script&gt;”

看看有没弹出对话框显示hello，有的话就有跨站漏洞
</code></pre></li>
</ul>
</li>
<li><p>URL参数中进行SQL注入</p>
<ul>
<li>SQL注入全称是SQL Injection ，当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击，如查询、插入数据时</li>
<li>测试方法： URL中写入SQL注入语句，看是否被执行<br>如：www.cnblogs.com/javame这个网站中，选择登陆设置用户名为 admin ‘ or ‘1’=’1 密码为任意数字 ，点击登录就可以登陆。一般情况下要进行SQL注入攻击，需要对数据库类型、表名、判断逻辑、查询语句等比较清楚才能够写出有效的SQL注入语句</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><h6>表单提交安全测试</h6><p></p>
<ul>
<li>适用范围：有表单提交的地方、有HTTP请求的地方</li>
<li>测试关注点<ul>
<li>表单中注入XSS脚本<ul>
<li>即在表单填写框中直接注入JS脚本如在表单中输入XSS脚本，程序是不应该让脚本执行的</li>
</ul>
</li>
<li>表单中注入SQL 脚本<ul>
<li>与URL中参数进行XSS注入类似，就是在表单中写入SQL注入脚本提交看是否会有问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<p></p><h6>Session测试</h6><p></p>
<ul>
<li>Session是客户端与服务器端建立的会话，总是放在服务器上的，服务器会为每次会话建立一个sessionId，每个客户会跟一个sessionID对应，并不是关闭浏览器就结束了本次会话，通常是用户执行“退出”操作或者会话超时时才会结束</li>
<li>测试关注点<ul>
<li>Session互窜<ul>
<li>Session互窜即用户A的操作被用户B执行了</li>
<li>验证Session互窜，其原理还是基于权限控制，如某笔订单只能是A进行操作，或者只能是A才能看到的页面，但是B的session窜进来却能够获得A的订单详情等</li>
<li>Session互窜方法<ul>
<li>多TAB浏览器，在两个TAB页中都保留的是用户A的session记录，然后在其中一个TAB页执行退出操作，登陆用户B，此时两个TAB页都是B的session，然后在另一个A的页面执行操作，查看是否能成功。预期结果：有权限控制的操作，B不能执行A页面的操作，应该报错，没有权限控制的操作，B执行了A页面操作后，数据记录是B的而不是A的</li>
</ul>
</li>
</ul>
</li>
<li>Session超时<ul>
<li>基于Session原理，需要验证系统session是否有超时机制，还需要验证session超时后功能是否还能继续走下去</li>
<li>测试方法：<ul>
<li>打开一个页面，等着10分钟session超时时间到了，然后对页面进行操作，查看效果</li>
<li>多TAB浏览器，在两个TAB页中都保留的是用户A的session记录，然后在其中一个TAB页执行退出操作，马上在另外一个页面进行要验证的操作，查看是能继续到下一步还是到登录页面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/10/基本安全测试/" data-id="cjtyg84gh005s4gwv1nu5qqlr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安全测试/">安全测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-事务视图索引备份" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/09/事务视图索引备份/" class="article-date">
  <time datetime="2018-03-09T10:10:58.000Z" itemprop="datePublished">2018-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/09/事务视图索引备份/">事务视图索引备份</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>事务视图索引备份</h5><p></p>
<hr>
<hr>
<p></p><h6>事务</h6><p></p>
<ul>
<li><p>事务是一个不可分割的工作逻辑单元 </p>
<pre><code>begin;   #开始事务（指定事务从此处开始，后续的SQL语句都是一个整体）
update bank set currentMoney=currentMoney-1000 
where customerName=&apos;张三&apos;;
update bank set currentMoney=currentMoney+1000 
where customerName=&apos;李四&apos;;
commit;  #提交事务，事务结束

begin;
update bank set currentMoney=currentMoney-1000 
where customerName=&apos;张三&apos;;
update bank set currentMoney=currentMoney+1000 
where customerName=&apos;李四&apos;;
rollback;  #回滚事务，数据恢复到原始状态

#转账过程就是一个整体它需要两条UPDATE语句来完成，
这两条语句是一个整体如果其中任一条出现错误，
则整个转账业务也应取消，
两个账户中的余额应恢复到原来的数据，
从而确保转账前和转账后的余额不变，即都是1001元
</code></pre></li>
<li><p>事务必须具备以下四个属性，简称ACID 属性</p>
<ul>
<li>原子性（Atomicity）<ul>
<li>事务是一个完整的操作，事务的各步操作是不可分的(原子的)，要么都执行，要么都不执行</li>
</ul>
</li>
<li>一致性（Consistency）<ul>
<li>当事务完成时，数据必须处于一致状态</li>
</ul>
</li>
<li>隔离性（Isolation）<ul>
<li>并发事务之间彼此隔离、独立，它不应以任何方式依赖于或影响其他事务</li>
</ul>
</li>
<li>持久性（Durability）<ul>
<li>事务完成后,它对数据库的修改被永久保持</li>
</ul>
</li>
</ul>
</li>
<li>事务关闭<ul>
<li>默认情况下，每条单独的SQL语句视为一个事务，默认开启，即autocommit=1</li>
<li>关闭开启自动提交状态 set autocommit=0|1,0为关闭自动提交</li>
<li>关闭自动提交后，从下一条SQL语句开始则开启新事务，需使用commit或者rollback语句结束该事</li>
</ul>
</li>
</ul>
<p></p><h6>视图</h6><p></p>
<ul>
<li>视图是一张虚拟表<ul>
<li>表示一张表的部分数据或多张表的综合数据</li>
<li>其结构和数据是建立在对表的查询基础上</li>
</ul>
</li>
<li>视图中不存放数据<ul>
<li>数据存放在视图所引用的原始表中</li>
</ul>
</li>
<li>一个原始表，根据不同用户的不同需求，可以创建不同的视图</li>
<li><p>对视图数据进行添加、更新和删除操作直接影响所引用表中的数据</p>
<pre><code>#删除视图
drop view if exists view_name;
#创建视图
create view view_name(
    select ......
)
#查看视图
select ... from view_name;
</code></pre></li>
</ul>
<p></p><h6>索引</h6><p></p>
<ul>
<li>索引是一种有效组合数据的方式，为快速查找到指定记录</li>
<li>作用<ul>
<li>大大提高数据库的检索速度</li>
<li>改善数据库性能</li>
</ul>
</li>
<li><p>一般用的最多的就是主键索引和唯一索引</p>
<ul>
<li>一个主键将自动创建主键索引</li>
<li><p>索引列数据不重复UNIQUE</p>
<pre><code>create [UNIQUE] index index_stuName 
on student(studentName)

drop index index_name on table_name
#删除表时，该表的所有索引同时会被删除

show index from table_name   #查看索引
</code></pre></li>
</ul>
</li>
</ul>
<p></p><h6>备份</h6><p></p>
<ul>
<li><p>mysqldump是DOS系统下的命令，<br>在使用时无须进入mysql命令行，否则将无法执行</p>
<pre><code>mysqldump -uroot -p123456 mybank bank &gt;D:\Python\0309.sql
#备份
mysql -uroot -p123456 mybank &lt;D:\Python\0309.sql
#还原
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/09/事务视图索引备份/" data-id="cjtyg84f700504gwv1q051cfk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL学习/">MySQL学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-httpwatch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/httpwatch/" class="article-date">
  <time datetime="2018-03-08T05:49:23.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/httpwatch/">httpwatch</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>httpwatch</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>HttpWatch是一个可用于录制HTTP请求信息的工具，由Simtec Limited公司开发，其官网为：Http://www.httpwatch.com，HttpWatch只支持IE和Firefox，也就是说只有当你用IE或Firefox访问网页时，它才会进行录制，不像Sniffer和Omnipeek那样监控所有数据，但对于网站分析来说，已经是不可多得的利器了</li>
<li>HttpWatch是功能强大的网页数据分析工具，集成在IE工具栏，主要功能有网页摘要、cookies管理、缓存管理、消息头发送/接收，字符查询、POST数据、目录管理功能和报告输出。HttpWatch是一款能够收集并显示深层信息的软件，它不用代理服务器或一些复杂的网络监控工具，能够在显示网页的同时显示网页请求和回应的日志信息，甚至可以显示浏览器缓存和IE之间的交换信息，集成在IE工具栏</li>
<li>HttpWatch有两部分组成： <ul>
<li>1、一个是嵌入到IE或Firefox中用于收集、查看、保存HTTP信息的插件 </li>
<li>2、一个是独立运行的日志查看器，叫做HttpWatch Studio</li>
</ul>
</li>
</ul>
<p></p><h6>Time Chart</h6><p></p>
<ul>
<li>显示了一次请求应答过程中每个时间片段所花费的时间。一次完整的请求应答过程需要经历的时间片段如下：<br>Blocked-&gt;DNS Lookup-&gt;Connect    -&gt;Send -&gt;Wait    -&gt;Receive</li>
<li>各时间片段含义如下：<ul>
<li>Blocked（阻塞）：阻塞的时间主要包括预处理时间（如缓存查找）和网络排队等待时间，导致阻塞最主要原因是下载页面中的图片</li>
<li>DNS Lookup（域名解释）：域名解释时间主要是将主机名（如www.google.com）转化为相应的IP地址（216.239.59.99）的时间，在访问URL地址时，地址本身不能被直接访问，需要将它对应为相应的IP地址才能访问</li>
<li>Connect（连接）：连接时间是指与web服务器（或代理服务器）建立起TCP连接需要的时间，一个安全的HTTPS连接应该包含SSL握手的过程，让系统处于一种保持连接的状态，可以节约重复创建TCP连接的时间</li>
<li>Send（发送）：发送时间是指从客户端发送HTTP请求到服务器所花费的时间，并且发送数据大小会影响发送的时间，如上传文件花费的时间就比较长</li>
<li>Wait（等待）：等待时间是指服务器响应请求的时间，这个值包括网络延迟和服务器处理请求所花费的时间</li>
<li>Receive（接收）：接收时间是指服务器返回数据到客户端所花费的时间，这个时间受所返回消息内容大小、网络带宽和HTTP压缩比的影响</li>
<li>Cache Read（读cache）：读缓存时间是指从浏览器缓存中读取内容的时间</li>
</ul>
</li>
</ul>
<p></p><h6>Headers</h6><p></p>
<ul>
<li><p>Headers Sent的内容如下：</p>
<ul>
<li>(Request-Line)：包括HTTP提交请求方法、HTTP版本和URL子路径</li>
<li>Accept：可接受的文件类型，<em>/</em>表示所有</li>
<li>Accept-Encoding：可接受的纯文本之外的内容编码的类型</li>
<li>Accept-Language：可接受的返回数据的语言种类</li>
<li>Connection：指定该次请求回应结束后，如何处理连接</li>
<li>Cache-Control：指定请求和响应遵循的缓存机制</li>
<li>Location：用于重定向接收者到一个新URL地址</li>
<li>Host：请求连接的主机名</li>
<li>User-Agent：客户端标识浏览器类型</li>
</ul>
</li>
<li><p>Headers Received的内容如下：</p>
<ul>
<li>(Status-Line)：包括HTTP请求的状态码和HTTP版本信息</li>
<li>Connection：指定该次请求回应结束后，如何处理连接</li>
<li>Content-Language：内容数据的语言种类</li>
<li>Content-Length：传输的内容长度</li>
<li>Content-Type：内容数据的类型（Mini Type）</li>
<li>Date：发送HTTP消息的日期</li>
<li>Server：一种标明Web服务器软件及其版本号的</li>
<li>X-Cache：表明你的http request是由proxy server回的</li>
<li>Last-Modified：服务器上保存内容的最后修订时间</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/httpwatch/" data-id="cjtyg84ch003f4gwvrj19epu4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能测试/">性能测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-chown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/chown/" class="article-date">
  <time datetime="2018-03-08T05:48:02.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/chown/">chown</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>chown</h5><p></p>
<hr>
<hr>
<p></p><h6>简介</h6><p></p>
<ul>
<li>1.使用权限 : root</li>
<li><p>2.使用方式</p>
<pre><code>chown[-f][-h][-R] Owner [ :Group ] { File ... | Directory ... }
chown -R [-f ][-H| -L| -P] Owner [ :Group ] { File ... | Directory ... }
</code></pre></li>
<li><p>3.说明：Linux/Unix 是多人多工作业系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥<br>有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以<br>改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才<br>有这样的权限，一个字：更改与文件关联的所有者或组</p>
</li>
<li><p>4.描述：chown命令将 File 参数指定的文件的所有者更改为 Owner 参数指定的用户。Owner 参数的值可以是可在 /etc/passwd 文件中找到的用户标识或登录名。还可以选择性地指定组。Group 参数的值可以是可在 /etc/group 文件中找到的组标识或组名</p>
<pre><code>-f
禁止除用法消息之外的所有错误消息
-h
更改遇到的符号链接的所有权，而非符号链接指向的文件或目录的所有权
当遇到符号链接而您未指定 -h 标志时，chown 命令更改链接指向的文件或目录的所有权，而非链接本身的所有权
如果指定 -R 标志，chown 命令递归地降序指定的目录
-H
如果指定了 -R 选项，并且引用类型目录的文件的符号链接在命令行上指定，
chown 变量会更改由符号引用的目录的用户标识（和组标识，如果已指定）和所有在该目录下的文件层次结构中的所有文件
-L
如果指定了 -R 选项，并且引用类型目录的文件的符号在命令行上指定或在遍历文件层次结构期间遇到，
chown 命令会更改由符号链接引用的目录的用户标识（和组标识，如果已指定）和在该目录之下的文件层次结构中的所有文件
-P
如果指定了 -R 选项并且符号链接在命令行上指定或者在遍历文件层次结构期间遇到，则如果系统支持该操作，
则chown 命令会更改符号链接的所有者标识（和组标识，如果已指定）。chown 命令不会执行至文件层次结构的任何其它部分的符号链接
-R
递归地降序目录，更改每个文件的所有权。当遇到符号链接并且链接指向目录时，更改该目录的所有权，但不进一步遍历目录。
不过 -h、-H、-L or -P 标志也未指定，则当遇到符号链接并且该链接指向到目录时，该目录的组所有权更改但不会进一步遍历目录
</code></pre></li>
</ul>
<p></p><h6>示例</h6><p></p>
<ul>
<li><p>将档案 file1.txt 的拥有者设为 users 群体的使用者 tom : </p>
<pre><code>chown tom:users file1.txt 
</code></pre></li>
<li><p>将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 jerry : </p>
<pre><code>chown -R lamport:users * 
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/chown/" data-id="cjtyg84ca003a4gwvtf94jb1w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux学习/">Linux学习</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Page Object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/08/Page Object/" class="article-date">
  <time datetime="2018-03-08T03:30:46.000Z" itemprop="datePublished">2018-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/08/Page Object/">Page Object</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>Page Object</h5><p></p>
<hr>
<hr>
<p></p><h6>By元素定位</h6><p></p>
<ul>
<li><p>已经将By方法封装</p>
<pre><code>from selenium import webdriver
from selenium.webdriver.common.by import By

driver=webdriver.Firefox()
driver.get(&apos;http://www.baidu.com&apos;)
driver.find_element(By.ID,&apos;kw&apos;).clear()
driver.find_element(By.NAME,&apos;wd&apos;).send_keys(&apos;selenium&apos;)
driver.find_element(By.CLASS_NAME,&apos;s_ip&apos;).send_keys(&apos;study&apos;)
driver.find_element(By.CSS_SELECTOR,&apos;#kw&apos;).send_keys(&apos;Python&apos;)
driver.find_element(By.TAG_NAME,&apos;input&apos;)....
driver.find_element(By.LINK_TEXT,&apos;退出&apos;)...
driver.find_element(By.PARTIAL_LINK_TEXT,&apos;退&apos;)...
driver.find_element(By.XPATH,&apos;.//[@id=&quot;Title&quot;]&apos;)...
</code></pre></li>
</ul>
<p></p><h6>Page Object</h6><p></p>
<ul>
<li><p>Page Object是Selenium自动化测试项目开发实践的最佳设计模式之一，通过对界面元素和功能模块的封装减少冗余代码，同时在后期维护中，若元素定位或功能模块发生变化，只需要调整页面元素或功能模块封装的代码，提高测试用例的可维护性</p>
<pre><code>#basepage.py
from time import sleep
class Page:                         #页面基础类
    def __init__(self,driver):      #初始化
        self.driver=driver
        self.base_url=&apos;http://localhost&apos;
        self.timeout=10
    def _open(self,url):            #打开不同的子页面
        url_=self.base_url+url
        print(&apos;Test page is %s&apos;%url_)
        self.driver.maximize_window()
        self.driver.get(url_)
        sleep(3)
        assert self.driver.current_url==url_,&apos;Did not land on %s&apos;%url_
    def open(self):
        self._open(self.url)
    def find_element(self,*location): #元素定位方法封装
        return self.driver.find_element(*location)

#loginpage.py
from basepage import *
from selenium.webdriver.common.by import By
class LoginPage(Page):
    &apos;&apos;&apos;首页登录页面&apos;&apos;&apos;
    url=&apos;/&apos;
    username_loc=(By.NAME,&apos;username&apos;)         #定位器
    password_loc=(By.NAME,&apos;password&apos;)
    submit_loc=(By.NAME,&apos;Submit&apos;)
    def type_username(self,username):         #用户名输入框元素
        self.find_element(*self.username_loc).clear()
        self.find_element(*self.username_loc).send_keys(username)
    def type_password(self,password):         #密码输入框元素
        self.find_element(*self.password_loc).send_keys(password)
    def type_submit(self):                    #登录按钮元素
        self.find_element(*self.submit_loc).click()

def test_user_login(driver,username,password):#登录功能模块封装
    &apos;&apos;&apos;测试用户名密码是否可以登录&apos;&apos;&apos;
    login_page=LoginPage(driver)
    login_page.open()
    login_page.type_username(username)
    login_page.type_password(password)
    login_page.type_submit()

# test_login.py
from loginpage import *
from selenium import webdriver
driver=webdriver.Firefox()
username=&apos;51zxw&apos;
password=&apos;123456&apos;

test_user_login(driver,username,password)
sleep(3)
driver.quit()
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/08/Page Object/" data-id="cjtyg849y00264gwvt50ee0y5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-整合测试报告发送" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/07/整合测试报告发送/" class="article-date">
  <time datetime="2018-03-07T01:13:05.000Z" itemprop="datePublished">2018-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/07/整合测试报告发送/">整合测试报告发送</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>整合测试报告发送</h5><p></p>
<hr>
<hr>
<p></p><h6>将生成的最新测试报告发送到指定邮箱</h6><p></p>
<ul>
<li>文件路径如下：<ul>
<li>文件夹test_baidu<ul>
<li>文件夹test_case<ul>
<li>test_baidu.py</li>
</ul>
</li>
<li>文件夹test_report</li>
<li>文件send_test_email.py</li>
</ul>
</li>
</ul>
</li>
<li><p>send_test_email.py</p>
<pre><code>import unittest,time,smtplib,os
from BSTestRunner import BSTestRunner
from email.mime.text import MIMEText
from email.header import Header

def latest_report(report_dir):      #获取最新生成的测试报告
    lists=os.listdir(report_dir)
    lists.sort(key=lambda fn:os.path.getatime(report_dir+&apos;\\&apos;+fn))
    file=os.path.join(report_dir,lists[-1])
    return file
def send_mail(latest_report):       #发送邮件
    f=open(latest_report,&apos;rb&apos;)
    mail_content=f.read()
    f.close()

    smtpserver=&apos;smtp.163.com&apos;
    user=&apos;www_liuyongqian@163.com&apos;
    password=&apos;39a39b39c&apos;

    sender=&apos;www_liuyongqian@163.com&apos;
    receives=[&apos;272501447@qq.com&apos;,&apos;liuyongqian51@163.com&apos;]

    subject=&apos;Web 自动化测试结果&apos;

    msg=MIMEText(mail_content,&apos;html&apos;,&apos;utf-8&apos;)     #邮件正文
    msg[&apos;Subject&apos;]=Header(subject,&apos;utf-8&apos;)
    msg[&apos;From&apos;]=sender
    msg[&apos;To&apos;]=&apos;,&apos;.join(receives)

    smtp=smtplib.SMTP_SSL(smtpserver,465)
    smtp.helo(smtpserver)
    smtp.ehlo(smtpserver)
    smtp.login(user,password)

    print(&apos;Start send eamil...&apos;)
    smtp.sendmail(sender,receives,msg.as_string())
    smtp.quit()
    print(&apos;Send email end...&apos;)

if __name__==&apos;__main__&apos;:
    test_dir=&apos;./test_case&apos;
    report_dir=&apos;./test_report&apos;
    discovery=unittest.defaultTestLoader.discover(test_dir,pattern=&apos;test*.py&apos;)
    now=time.strftime(&apos;%Y-%m-%d %H_%M_%S&apos;)
    report_name=report_dir+&apos;/&apos;+now+&apos;result.html&apos;

    with open(report_name,&apos;wb&apos;) as f:
        runner=BSTestRunner(stream=f,title=&apos;Test Report&apos;,description=&apos;baidu search&apos;)
        runner.run(discovery)
    f.close()

    latest_report=latest_report(report_dir)  #获取最新测试报告
    send_mail(latest_report)                 #发送邮件报告
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/07/整合测试报告发送/" data-id="cjtyg84hy006o4gwvo1felbni" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-高级查询" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/06/高级查询/" class="article-date">
  <time datetime="2018-03-06T12:16:05.000Z" itemprop="datePublished">2018-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/06/高级查询/">高级查询</a>
    </h1>
  


      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
	  
	  
        <p></p><h5>高级查询</h5><p></p>
<hr>
<hr>
<p></p><h6>其他查询</h6><p></p>
<ul>
<li><p>IN，NOT IN（可返回多条记录）</p>
<pre><code>#查询学号为009最低分的课程名
select kcm from kcb
where kch in(
    select kch from cjb
    where cj in(
        select MIN(cj) from cjb
        where xh=&apos;009&apos;
    )and xh=&apos;009&apos;
)
</code></pre></li>
<li><p>LIMIT m,n<br>m表示从m+1条开始取值，n表示条数（在语句末尾取记录）</p>
</li>
<li><p>IS NULL，IS NOT NULL</p>
<pre><code>select kch from cjb 
where cj is not nul
</code></pre></li>
</ul>
<p></p><h6>分组查询</h6><p></p>
<ul>
<li><p>GROUP BY … HAVING…</p>
<pre><code>#统计每个班级人数且人数在30人以上的
select bj as &apos;班级&apos;,count(*) as &apos;人数&apos;
from xsb
group by bj
having count(*)&gt;30 
</code></pre></li>
<li><p>在SELECT语句中，WHERE、GROUP BY、HAVING子句的执行次序如下：</p>
<pre><code>* 1、WHERE子句从数据源中去掉不符合其搜索条件的数据
* 2、GROUP BY子句搜集数据行到各个组中
* 3、HAVING子句去掉不符合其组搜索条件的各组数据行
</code></pre></li>
</ul>
<p></p><h6>多表查询</h6><p></p>
<ul>
<li><p>等值连接（先连接后判断）</p>
<pre><code>#查询张三的数据库的成绩
select xm,kcm,cj
from xsb,kcb,cjb
where xsb.xh=cjb.xh and kcb.kch=cjb.kch
#主表1.主键=从表.外键，主表2.主键=从表.外键
and xm=&apos;张三&apos; and kcm=&apos;数据库&apos;
</code></pre></li>
<li>注：查询显示字段或者其他条件中字段在几张表内有重复，需要在字段前加上表名，表名.字段名</li>
<li><p>内连接（先判断再连接）</p>
<pre><code>#查询不是北京、上海的学生的QTP成绩
select kcm,cj,jg
from xsb inner join cjb on xsb.xh=cjb.xh
inner join kcb on kcb.kch=cjb.kch
and jg not in(&apos;北京&apos;,&apos;上海&apos;)
and kcm=&apos;QTP&apos;
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/06/高级查询/" data-id="cjtyg84k700804gwvlnzyo38q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL学习/">MySQL学习</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/10/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django学习/">Django学习</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA项目部署/">JAVA项目部署</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux学习/">Linux学习</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB数据库/">MongoDB数据库</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL学习/">MySQL学习</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx学习/">Nginx学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python学习/">Python学习</a><span class="tag-list-count">27</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis数据库/">Redis数据库</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web前端/">Web前端</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全测试/">安全测试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫学习/">爬虫学习</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络基础知识/">网络基础知识</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自动化测试/">自动化测试</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件工具/">软件工具</a><span class="tag-list-count">7</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django学习/" style="font-size: 12.22px;">Django学习</a> <a href="/tags/JAVA项目部署/" style="font-size: 13.33px;">JAVA项目部署</a> <a href="/tags/Linux学习/" style="font-size: 18.89px;">Linux学习</a> <a href="/tags/MongoDB数据库/" style="font-size: 12.22px;">MongoDB数据库</a> <a href="/tags/MySQL学习/" style="font-size: 18.89px;">MySQL学习</a> <a href="/tags/Nginx学习/" style="font-size: 10px;">Nginx学习</a> <a href="/tags/Python学习/" style="font-size: 20px;">Python学习</a> <a href="/tags/Redis数据库/" style="font-size: 15.56px;">Redis数据库</a> <a href="/tags/Web前端/" style="font-size: 16.67px;">Web前端</a> <a href="/tags/大数据/" style="font-size: 13.33px;">大数据</a> <a href="/tags/安全测试/" style="font-size: 11.11px;">安全测试</a> <a href="/tags/性能测试/" style="font-size: 15.56px;">性能测试</a> <a href="/tags/爬虫学习/" style="font-size: 17.78px;">爬虫学习</a> <a href="/tags/网络基础知识/" style="font-size: 10px;">网络基础知识</a> <a href="/tags/自动化测试/" style="font-size: 12.22px;">自动化测试</a> <a href="/tags/软件工具/" style="font-size: 14.44px;">软件工具</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/01/jemkins自动化部署-后台项目构建/">jemkins自动化部署--后台项目构建</a>
          </li>
        
          <li>
            <a href="/2019/03/25/MySQL数据库读写分离/">MySQL数据库读写分离</a>
          </li>
        
          <li>
            <a href="/2019/03/25/MySQL数据库主从复制/">MySQL数据库主从复制</a>
          </li>
        
          <li>
            <a href="/2019/03/24/清理内存缓存与交换空间/">清理内存缓存与交换空间</a>
          </li>
        
          <li>
            <a href="/2019/03/23/Nginx转发SSH代理-Stream模块/">Nginx转发SSH代理-Stream模块</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
       Email:<a>liuyongqian51@163.com</a><br />
          QQ:<a>272501447</a><br />
	  Github:<a></a>
    </div>
  </div>

  
  

</aside>


        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 刘永前<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>

</footer>


    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>